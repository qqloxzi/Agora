---
// components/goboard.astro
const { problem, isTeacher = false } = Astro.props;
---

<div class="go-app" data-problem={problem ? JSON.stringify(problem) : null} data-teacher={isTeacher.toString()}>
  
  <div class="status"></div>

  <div class="go-container">
    <canvas class="goBoard"></canvas>
  </div>

  <div class="bottom-controls">
    
    {!isTeacher && problem && (
      <div class="control-item tooltip" data-tip={problem.turn === 'black' ? 'Sƒ±ra Siyahƒ±n' : 'Sƒ±ra Beyazƒ±n'}>
        <div class={`turn-indicator ${problem.turn}`}></div>
      </div>
    )}

    {isTeacher && (
        <div class="teacher-group">
            <button class="control-btn tooltip" id="undoBtn" data-tip="Geri Al">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 14 4 9l5-5"/><path d="M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5v0a5.5 5.5 0 0 1-5.5 5.5H11"/></svg>
            </button>

            <div class="divider"></div>

            <button class="control-btn tooltip" id="markCorrectBtn" data-tip="DOƒûRU Yol Olarak ƒ∞≈üaretle" style="color: #2ecc71; border-color: #2ecc71;">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg>
            </button>
            <button class="control-btn tooltip" id="markWrongBtn" data-tip="YANLI≈û Yol Olarak ƒ∞≈üaretle" style="color: #e74c3c; border-color: #e74c3c;">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
            </button>

            <div class="divider"></div>

            <button class="control-btn setupBtn tooltip" data-tip="Ta≈ü Dizme Modu">‚öôÔ∏è</button>
            <button class="control-btn recordBtn tooltip" data-tip="Kayƒ±t Modu">‚è∫</button>
            <button class="control-btn exportBtn tooltip" data-tip="JSON ƒ∞ndir">üíæ</button>
            
            <button class="control-btn colorToggleBtn tooltip" data-tip="Renk Deƒüi≈ütir">
               <div class="turn-indicator black" id="teacherColorIndicator"></div>
            </button>

            <div class="divider"></div>

            <button class="control-btn resetBtn tooltip" data-tip="Sƒ±fƒ±rla">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
            </button>
        </div>
    )}
  </div>
</div>

<style>
  .go-app { text-align: center; margin-bottom: 2rem; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; display: flex; flex-direction: column; align-items: center; }
  
  .status { font-size: 1.1rem; font-weight: bold; margin-bottom: 10px; height: 1.5em; color: #ffffff; text-shadow: 0 1px 3px rgba(0,0,0,0.6); transition: color 0.3s ease; }

  .go-container { display: inline-block; padding: 10px; background-color: #eebb66; border-radius: 4px; box-shadow: 0 10px 30px rgba(0,0,0,0.4); border: 1px solid #d4a753; position: relative; z-index: 10; }
  canvas { cursor: pointer; display: block; border-radius: 2px; max-width: 100%; height: auto; }

  .bottom-controls { display: flex; align-items: center; justify-content: center; gap: 15px; margin-top: 20px; padding: 8px 20px; background: rgba(255, 255, 255, 0.1); border-radius: 30px; border: 1px solid rgba(255, 255, 255, 0.15); backdrop-filter: blur(5px); }
  .bottom-controls:empty { display: none; }

  .teacher-group { display: flex; align-items: center; gap: 10px; }
  .divider { width: 1px; height: 25px; background: rgba(255,255,255,0.2); margin: 0 5px; }

  .control-btn { width: 42px; height: 42px; border-radius: 50%; background: rgba(255, 255, 255, 0.15); border: 1px solid rgba(255, 255, 255, 0.2); color: white; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s ease; font-size: 1.2rem; }
  .control-btn:hover { background: rgba(255, 255, 255, 0.3); transform: scale(1.1); }
  .control-btn.active { background: #3498db; border-color: #2980b9; box-shadow: 0 0 10px rgba(52, 152, 219, 0.5); }

  .turn-indicator { width: 20px; height: 20px; border-radius: 50%; box-shadow: 0 2px 4px rgba(0,0,0,0.4); }
  .turn-indicator.black { background: #000; border: 1px solid rgba(255,255,255,0.2); }
  .turn-indicator.white { background: #fff; border: 1px solid #ccc; }

  .tooltip { position: relative; }
  .tooltip:hover::after { content: attr(data-tip); position: absolute; bottom: 125%; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.9); color: #fff; padding: 5px 10px; border-radius: 6px; font-size: 0.8rem; white-space: nowrap; pointer-events: none; opacity: 0; animation: fadeIn 0.2s forwards; z-index: 20; }
  @keyframes fadeIn { to { opacity: 1; } }
</style>

<script>
  const setupBoard = () => {
    document.querySelectorAll('.go-app').forEach(app => {
      if (app.getAttribute('data-initialized')) return;
      
      const canvas = app.querySelector('.goBoard') as HTMLCanvasElement;
      const statusDiv = app.querySelector('.status') as HTMLElement;
      const isTeacher = app.getAttribute('data-teacher') === 'true';
      const ctx = canvas.getContext('2d', { alpha: false });
      if (!ctx) return;

      let size = 9; 
      const resolution = 2; const boardDisplaySize = 500; let padding = 30 * resolution; 
      let mode = isTeacher ? 'SETUP' : 'SOLVE';
      
      let stones: any[] = []; 
      let currentColor = 'black'; 
      let initialStonesState = ""; 
      
      let moveTree: any = { children: [] }; 
      let currentNode: any = moveTree;      
      let currentPathStack: any[] = [];       

      let hoverPos = { x: -1, y: -1 };

      canvas.width = boardDisplaySize * resolution; canvas.height = boardDisplaySize * resolution;
      canvas.style.width = `${boardDisplaySize}px`; canvas.style.height = `${boardDisplaySize}px`;

      const initStones = (newSize) => { 
          stones = Array(newSize).fill(0).map(() => Array(newSize).fill(null)); 
      };
      initStones(size);

      // --- VERƒ∞ Y√úKLEME ---
      const savedData = app.getAttribute('data-problem');
      if (savedData) {
        try {
          const prob = JSON.parse(savedData);
          size = prob.size || 9;
          initStones(size);
          
          // BA≈ûLANGI√á RENGƒ∞Nƒ∞ AYARLA
          // Eƒüer problemde sƒ±ra belirtildiyse (prob.turn), o renkten ba≈üla. Yoksa Siyah.
          if (prob.turn) {
              currentColor = prob.turn;
          } else {
              currentColor = 'black';
          }

          if (prob.initialState) {
             initialStonesState = prob.initialState;
             const parsedState = JSON.parse(prob.initialState);
             if (Array.isArray(parsedState)) {
                if (Array.isArray(parsedState[0])) stones = parsedState;
                else (parsedState as any[]).forEach((s: any) => { if (s && s.x !== undefined) stones[s.x][s.y] = { color: s.color }; });
             }
          }
          if (prob.solution) {
              if (Array.isArray(prob.solution)) {
                  let ptr = moveTree;
                  prob.solution.forEach((move: any) => {
                      const newNode = { ...move, children: [], status: null };
                      ptr.children.push(newNode);
                      ptr = newNode;
                  });
                  ptr.status = 'correct';
              } else {
                  moveTree = prob.solution;
              }
          }
          currentNode = moveTree; 
          if (!isTeacher) mode = 'SOLVE';
        } catch (e) { console.error("Veri y√ºkleme hatasƒ±", e); }
      }

      // --- √áƒ∞Zƒ∞M ---
      const drawBoard = () => {
        ctx.fillStyle = "#eebb66"; ctx.fillRect(0, 0, canvas.width, canvas.height);
        const cellSize = (canvas.width - padding * 2) / (size - 1);

        ctx.lineWidth = 1.5 * resolution; ctx.strokeStyle = '#000'; ctx.beginPath();
        for (let i = 0; i < size; i++) {
          const pos = Math.round(padding + i * cellSize);
          ctx.moveTo(pos, padding); ctx.lineTo(pos, canvas.height - padding);
          ctx.moveTo(padding, pos); ctx.lineTo(canvas.width - padding, pos);
          ctx.fillStyle = '#000'; ctx.font = `bold ${12 * resolution}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
          const label = String.fromCharCode(65 + (i >= 8 ? i + 1 : i));
          ctx.fillText(label, pos, canvas.height - (10 * resolution)); ctx.fillText((size - i).toString(), (15 * resolution), pos);
        }
        ctx.stroke();

        const hoshiCoords = size === 19 ? [3, 9, 15] : size === 13 ? [3, 6, 9] : [2, 4, 6];
        if (size >= 9) {
          ctx.fillStyle = '#000';
          hoshiCoords.forEach(hx => { hoshiCoords.forEach(hy => {
              ctx.beginPath(); ctx.arc(padding + hx * cellSize, padding + hy * cellSize, 3 * resolution, 0, Math.PI * 2); ctx.fill();
            }); });
        }

        stones.forEach((row: any, x) => row.forEach((stone: any, y) => { 
            if (stone) drawStone(x, y, stone.color, cellSize, 1); 
        }));

        // GHOST STONE (√ñƒüretmen modunda her zaman, Solve modunda sadece sƒ±rasƒ± gelen kullanƒ±cƒ± i√ßin)
        // Kullanƒ±cƒ± hamlesini g√∂stermek i√ßin currentColor kullanƒ±yoruz.
        if (hoverPos.x >= 0 && hoverPos.x < size && hoverPos.y >= 0 && hoverPos.y < size) {
          if (!stones[hoverPos.x][hoverPos.y]) {
            drawStone(hoverPos.x, hoverPos.y, currentColor, cellSize, 0.5);
          }
        }
      };

      const drawStone = (x, y, color, cellSize, opacity) => {
        const posX = padding + x * cellSize; const posY = padding + y * cellSize; const radius = cellSize * 0.48;
        ctx.save(); ctx.globalAlpha = opacity;
        if (opacity === 1) { ctx.shadowColor = "rgba(0,0,0,0.3)"; ctx.shadowBlur = 3 * resolution; ctx.shadowOffsetX = 1 * resolution; ctx.shadowOffsetY = 1 * resolution; }
        ctx.beginPath(); ctx.arc(posX, posY, radius, 0, Math.PI * 2);
        if (color === 'black') {
          const grad = ctx.createRadialGradient(posX - radius*0.3, posY - radius*0.3, radius*0.1, posX, posY, radius);
          grad.addColorStop(0, "#555"); grad.addColorStop(1, "#000"); ctx.fillStyle = grad;
        } else {
          const grad = ctx.createRadialGradient(posX - radius*0.3, posY - radius*0.3, radius*0.1, posX, posY, radius);
          grad.addColorStop(0, "#fff"); grad.addColorStop(1, "#ddd"); ctx.fillStyle = grad;
        }
        ctx.fill(); 
        if (color === 'white' && opacity === 1) { ctx.lineWidth = 1; ctx.strokeStyle = "#ccc"; ctx.stroke(); }
        ctx.restore();
      };

      // --- EVENTS ---
      canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height;
        const mouseX = (e.clientX - rect.left) * scaleX - padding;
        const mouseY = (e.clientY - rect.top) * scaleY - padding;
        const cellSize = (canvas.width - padding * 2) / (size - 1);
        const x = Math.round(mouseX / cellSize); const y = Math.round(mouseY / cellSize);
        if (x >= 0 && x < size && y >= 0 && y < size) { if (hoverPos.x !== x || hoverPos.y !== y) { hoverPos = { x, y }; canvas.style.cursor = 'pointer'; drawBoard(); } } 
        else { if (hoverPos.x !== -1) { hoverPos = { x: -1, y: -1 }; canvas.style.cursor = 'default'; drawBoard(); } }
      });
      canvas.addEventListener('mouseleave', () => { hoverPos = { x: -1, y: -1 }; drawBoard(); });

      // --- TIKLAMA MANTIƒûI ---
      canvas.addEventListener('click', (e) => {
        if (hoverPos.x === -1) return;
        const x = hoverPos.x; const y = hoverPos.y;

        if (mode === 'SETUP') { 
            stones[x][y] = stones[x][y] && stones[x][y].color === currentColor ? null : { color: currentColor }; 
            drawBoard();
        } 
        
        else if (mode === 'RECORD') { 
            if (stones[x][y]) return; 
            let existingChild = currentNode.children.find((child: any) => child.x === x && child.y === y);

            if (existingChild) {
                stones[x][y] = { color: existingChild.color };
                currentPathStack.push(currentNode);
                currentNode = existingChild;
                // Sƒ±rayƒ± deƒüi≈ütir
                currentColor = currentColor === 'black' ? 'white' : 'black';
                updateStatusText(`Mevcut dalda ilerlendi.`, '#3498db');
            } else {
                const newNode = { x, y, color: currentColor, children: [], status: null };
                currentNode.children.push(newNode);
                stones[x][y] = { color: currentColor };
                currentPathStack.push(currentNode);
                currentNode = newNode;
                // Sƒ±rayƒ± deƒüi≈ütir
                currentColor = currentColor === 'black' ? 'white' : 'black';
                updateStatusText("Yeni varyasyon kaydediliyor...", '#f1c40f');
            }
            drawBoard();
        } 
        
        else if (mode === 'SOLVE') {
            if (stones[x][y]) return;
            const nextNode = currentNode.children.find((child: any) => child.x === x && child.y === y);

            if (nextNode) {
                // 1. √ñƒûRENCƒ∞ HAMLESƒ∞
                stones[x][y] = { color: nextNode.color };
                currentNode = nextNode;
                
                // Sƒ±rayƒ± deƒüi≈ütir (√ñƒürenci oynadƒ±, sƒ±ra bilgisayarda)
                currentColor = currentColor === 'black' ? 'white' : 'black';
                drawBoard();
                checkNodeStatus(currentNode);

                // 2. Bƒ∞LGƒ∞SAYAR HAMLESƒ∞ (Yanƒ±t Varsa)
                if (currentNode.children.length > 0 && !currentNode.status) {
                    setTimeout(() => {
                        const responseNode = currentNode.children[0];
                        stones[responseNode.x][responseNode.y] = { color: responseNode.color };
                        currentNode = responseNode;
                        
                        // Sƒ±rayƒ± tekrar √∂ƒürenciye ver
                        currentColor = currentColor === 'black' ? 'white' : 'black';
                        
                        drawBoard();
                        checkNodeStatus(currentNode);
                    }, 500); 
                }
            } else {
                updateStatusText("Tanƒ±msƒ±z hamle. (Yanlƒ±≈ü olabilir)", '#e74c3c');
                if (typeof (window as any).handleMoveResult === 'function') (window as any).handleMoveResult(false);
            }
        }
      });

      function checkNodeStatus(node) {
          if (node.status === 'correct') {
              updateStatusText("Tebrikler! Doƒüru √á√∂z√ºm.", '#2ecc71');
              if (typeof (window as any).handleMoveResult === 'function') (window as any).handleMoveResult(true);
              if (typeof (window as any).unlockNextButton === 'function') (window as any).unlockNextButton();
          } else if (node.status === 'wrong') {
              updateStatusText("Yanlƒ±≈ü yol! Ba≈üarƒ±sƒ±z.", '#e74c3c');
              if (typeof (window as any).handleMoveResult === 'function') (window as any).handleMoveResult(false);
          }
      }

      function updateStatusText(text, color) {
          if (statusDiv) { statusDiv.innerText = text; statusDiv.style.color = color; }
      }

      if (isTeacher) {
          app.querySelector('#undoBtn')?.addEventListener('click', () => {
              if (currentPathStack.length > 0) {
                  const lastNode = currentNode;
                  stones[lastNode.x][lastNode.y] = null;
                  currentNode = currentPathStack.pop();
                  // Geri alƒ±nca rengi de geri al
                  currentColor = currentColor === 'black' ? 'white' : 'black';
                  updateStatusText("Geri alƒ±ndƒ±.", '#fff');
                  drawBoard();
              }
          });

          app.querySelector('#markCorrectBtn')?.addEventListener('click', () => {
              if (currentNode === moveTree) return;
              currentNode.status = 'correct';
              updateStatusText("Bu dal 'DOƒûRU' i≈üaretlendi.", '#2ecc71');
          });

          app.querySelector('#markWrongBtn')?.addEventListener('click', () => {
              if (currentNode === moveTree) return;
              currentNode.status = 'wrong';
              updateStatusText("Bu dal 'YANLI≈û' i≈üaretlendi.", '#e74c3c');
          });

          app.querySelector('.setupBtn')?.addEventListener('click', () => updateUI('SETUP'));
          app.querySelector('.recordBtn')?.addEventListener('click', () => updateUI('RECORD'));
          
          app.querySelector('.exportBtn')?.addEventListener('click', () => { 
            const data = { 
                id: `prob-${Date.now()}`, 
                size, 
                turn: currentColor, // KAYIT SIRASINDAKƒ∞ BA≈ûLANGI√á RENGƒ∞Nƒ∞ KAYDET
                initialState: JSON.stringify(stones), 
                solution: moveTree 
            }; 
            console.log(JSON.stringify(data, null, 2)); alert("Aƒüa√ß yapƒ±sƒ± (Tree) Console'a yazdƒ±rƒ±ldƒ±!");
          });
          
          const colorBtn = app.querySelector('.colorToggleBtn');
          if(colorBtn) colorBtn.addEventListener('click', () => {
            currentColor = currentColor === 'black' ? 'white' : 'black';
            const indicator = document.getElementById('teacherColorIndicator');
            if(indicator) { indicator.classList.toggle('black'); indicator.classList.toggle('white'); }
          });
      }

      const updateUI = (newMode) => {
        mode = newMode;
        app.querySelectorAll('.control-btn').forEach(btn => btn.classList.remove('active'));
        if(newMode === 'SETUP') app.querySelector('.setupBtn')?.classList.add('active');
        if(newMode === 'RECORD') app.querySelector('.recordBtn')?.classList.add('active');

        if (newMode === 'RECORD' && mode === 'SETUP') {
             initialStonesState = JSON.stringify(stones);
             moveTree = { children: [] }; 
             currentNode = moveTree;
             currentPathStack = [];
             updateStatusText("Kayƒ±t Ba≈üladƒ±.", '#f1c40f');
        }
        if (newMode === 'SETUP') {
            updateStatusText("Ta≈ülarƒ± dizin.", '#fff');
        }
      };

      app.querySelector('.resetBtn')?.addEventListener('click', () => {
         updateStatusText("", "#fff");
         if (isTeacher && mode === 'SETUP') { initStones(size); }
         else { 
             // RESET: Ba≈ülangƒ±√ß state'ine ve rengine d√∂n
             const probData = savedData ? JSON.parse(savedData) : {};
             if (probData.turn) currentColor = probData.turn; 
             else currentColor = 'black';

             if(initialStonesState) {
                 const parsed = JSON.parse(initialStonesState);
                 if(Array.isArray(parsed) && Array.isArray(parsed[0])) stones = parsed; 
                 else { initStones(size); if(Array.isArray(parsed)) (parsed as any[]).forEach((s: any) => {if(s) stones[s.x][s.y] = {color:s.color}}); }
             } else { initStones(size); }
             
             currentNode = moveTree; 
             currentPathStack = [];
         }
         drawBoard();
      });

      app.setAttribute('data-initialized', 'true');
      drawBoard();
    });
  };
  
  document.addEventListener('astro:page-load', setupBoard);
  document.addEventListener('DOMContentLoaded', setupBoard);
</script>