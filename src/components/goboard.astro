---
// components/goboard.astro
const { problem, isTeacher = false } = Astro.props;
---

<div class="go-app" data-problem={problem ? JSON.stringify(problem) : null} data-teacher={isTeacher.toString()}>
  
  {!isTeacher && problem && (
    <div class="top-info-bar">
      <div class="turn-badge">
        <div class={`turn-indicator ${problem.turn}`}></div>
        <span>{problem.turn === 'black' ? 'Siyah Oynar' : 'Beyaz Oynar'}</span>
      </div>
    </div>
  )}

  <div class="status"></div>

  <div class="go-container">
    <canvas class="goBoard"></canvas>
  </div>

  <div class="bottom-action-bar">
    
    <button class="control-btn resetBtn tooltip" data-tip="Ba≈üa D√∂n / Sƒ±fƒ±rla">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
    </button>

    {isTeacher && (
        <div class="teacher-tools-right">
            <button class="control-btn tooltip" id="undoBtn" data-tip="Geri Al">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 14 4 9l5-5"/><path d="M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5v0a5.5 5.5 0 0 1-5.5 5.5H11"/></svg>
            </button>

            <div class="divider"></div>

            <button class="control-btn tooltip" id="markCorrectBtn" data-tip="DOƒûRU Yol" style="color: #2ecc71; border-color: rgba(46, 204, 113, 0.5);">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg>
            </button>
            <button class="control-btn tooltip" id="markWrongBtn" data-tip="YANLI≈û Yol" style="color: #e74c3c; border-color: rgba(231, 76, 60, 0.5);">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
            </button>

            <div class="divider"></div>

            <button class="control-btn setupBtn tooltip" data-tip="Kurulum (Dizme)">‚öôÔ∏è</button>
            <button class="control-btn recordBtn tooltip" data-tip="Kayƒ±t Ba≈ülat">‚è∫</button>
            <button class="control-btn exportBtn tooltip" data-tip="JSON ƒ∞ndir">üíæ</button>
            
            <button class="control-btn colorToggleBtn tooltip" data-tip="Renk Deƒüi≈ütir">
               <div class="turn-indicator black" id="teacherColorIndicator"></div>
            </button>
        </div>
    )}

  </div>
</div>

<style>
  /* --- TEMA RENKLERƒ∞ --- */
  :root {
    --status-text: #ffffff; /* Koyu modda beyaz yazƒ± */
    --status-shadow: 0 1px 3px rgba(0,0,0,0.8);
  }

  /* A√ßƒ±k Mod Algƒ±lamasƒ± */
  :global(body.light) .go-app {
    --status-text: #2c3e50; /* A√ßƒ±k modda koyu yazƒ± */
    --status-shadow: none;  /* G√∂lge yok */
  }

  .go-app { 
    text-align: center; 
    margin-bottom: 2rem; 
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    position: relative; 
  }
  
  /* Durum Yazƒ±sƒ± */
  .status { 
    font-size: 1.1rem; 
    font-weight: bold; 
    margin-bottom: 5px; 
    height: 1.5em; 
    color: var(--status-text); 
    text-shadow: var(--status-shadow); 
    transition: color 0.3s ease; 
  }

  /* √úST Bƒ∞LGƒ∞ */
  .top-info-bar { margin-bottom: 10px; display: flex; justify-content: center; width: 100%; }
  
  /* SIRA Kƒ∞MDE ROZETƒ∞ */
  .turn-badge { 
    display: flex; align-items: center; gap: 10px; 
    background: #2c3e50; 
    border: 1px solid #34495e; 
    padding: 6px 16px; border-radius: 20px; 
    color: #fff; 
    font-weight: 600; font-size: 0.95rem; 
    box-shadow: 0 4px 10px rgba(0,0,0,0.3); 
  }

  /* TAHTA */
  .go-container { 
    display: inline-block; padding: 10px; 
    background-color: #eebb66; 
    border-radius: 4px; 
    box-shadow: 0 15px 35px rgba(0,0,0,0.5); 
    border: 1px solid #d4a753; 
    position: relative; z-index: 10; 
    width: 100%;
    max-width: 500px; 
    aspect-ratio: 1 / 1; 
    margin: 0 auto;
    flex-wrap: wrap; 
    overflow: hidden
  }
  canvas { cursor: pointer; display: block; border-radius: 2px; max-width: 100%; height: auto; }

  /* ALT √áUBUK */
  .bottom-action-bar { width: 100%; max-width: 520px; display: flex; justify-content: flex-start; align-items: center; margin-top: 15px; position: relative; }
  .teacher-tools-right { margin-left: auto; display: flex; gap: 10px; align-items: center; }
  
  .divider { 
    width: 1px; height: 25px; 
    background: rgba(255,255,255,0.3); 
    margin: 0 5px; 
  }

  /* BUTONLAR */
  .control-btn { 
    width: 45px; height: 45px; border-radius: 50%; 
    background: #2c3e50; 
    border: 2px solid #34495e; 
    color: white; 
    display: flex; align-items: center; justify-content: center; 
    cursor: pointer; transition: all 0.2s ease; 
    font-size: 1.2rem; 
    box-shadow: 0 3px 6px rgba(0,0,0,0.3);
    flex-shrink: 0;
  }
  
  .control-btn:hover { 
    background: #1a252f; 
    transform: scale(1.1); 
    color: #fff; 
    border-color: #2c3e50;
  }
  
  .control-btn.active { 
    background: #3498db; 
    border-color: #2980b9; 
    box-shadow: 0 0 10px rgba(52, 152, 219, 0.5); 
  }

  .turn-indicator { width: 18px; height: 18px; border-radius: 50%; box-shadow: 0 2px 4px rgba(0,0,0,0.4); }
  .turn-indicator.black { background: #000; border: 1px solid rgba(255,255,255,0.2); }
  .turn-indicator.white { background: #fff; border: 1px solid #ccc; }

  .tooltip { position: relative; }
  .tooltip:hover::after { content: attr(data-tip); position: absolute; bottom: 125%; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.9); color: #fff; padding: 5px 10px; border-radius: 6px; font-size: 0.8rem; white-space: nowrap; pointer-events: none; opacity: 0; animation: fadeIn 0.2s forwards; z-index: 20; }
  @keyframes fadeIn { to { opacity: 1; } }
</style>

<script>
  const setupBoard = () => {
    document.querySelectorAll('.go-app').forEach(app => {
      if (app.getAttribute('data-initialized')) return;
      
      const canvas = app.querySelector('.goBoard') as HTMLCanvasElement;
      const statusDiv = app.querySelector('.status') as HTMLElement;
      const isTeacher = app.getAttribute('data-teacher') === 'true';
      const ctx = canvas.getContext('2d', { alpha: false });
      if (!ctx) return;

      // --- STATE ---
      let size = 9; 
      const resolution = 2; const boardDisplaySize = 500; let padding = 30 * resolution; 
      let mode = isTeacher ? 'SETUP' : 'SOLVE';
      
      let stones: any[] = []; 
      let currentColor = 'black'; 
      let initialStonesState = ""; 
      let recordingStartColor = 'black'; 

      let moveTree: any = { children: [] }; 
      let currentNode: any = moveTree;      
      let currentPathStack: any[] = [];       

      let hoverPos = { x: -1, y: -1 };

      canvas.width = boardDisplaySize * resolution; canvas.height = boardDisplaySize * resolution;
      canvas.style.width = `${boardDisplaySize}px`; canvas.style.height = `${boardDisplaySize}px`;

      const initStones = (newSize) => { 
          stones = Array(newSize).fill(0).map(() => Array(newSize).fill(null)); 
      };
      initStones(size);

      // --- GO MANTIƒûI ---
      const isOnBoard = (x, y) => x >= 0 && x < size && y >= 0 && y < size;

      const getLiberties = (x, y, color, checked = new Set()) => {
          const key = `${x},${y}`;
          if (checked.has(key)) return 0;
          checked.add(key);
          let liberties = 0;
          const neighbors = [[x+1, y], [x-1, y], [x, y+1], [x, y-1]];
          neighbors.forEach(([nx, ny]) => {
              if (!isOnBoard(nx, ny)) return;
              const stone = stones[nx][ny];
              if (!stone) liberties++;
              else if (stone.color === color) liberties += getLiberties(nx, ny, color, checked);
          });
          return liberties;
      };

      const removeGroup = (x, y, color) => {
          const stone = stones[x][y];
          if (!stone || stone.color !== color) return;
          stones[x][y] = null;
          const neighbors = [[x+1, y], [x-1, y], [x, y+1], [x, y-1]];
          neighbors.forEach(([nx, ny]) => {
              if (isOnBoard(nx, ny)) removeGroup(nx, ny, color);
          });
      };

      const playMove = (x, y, color) => {
          if (stones[x][y]) return false;
          stones[x][y] = { color };
          let captured = false;
          const opponent = color === 'black' ? 'white' : 'black';
          const neighbors = [[x+1, y], [x-1, y], [x, y+1], [x, y-1]];

          neighbors.forEach(([nx, ny]) => {
              if (isOnBoard(nx, ny) && stones[nx][ny] && stones[nx][ny].color === opponent) {
                  if (getLiberties(nx, ny, opponent) === 0) {
                      removeGroup(nx, ny, opponent);
                      captured = true;
                  }
              }
          });

          if (!captured && getLiberties(x, y, color) === 0) {
              stones[x][y] = null;
              updateStatusText("ƒ∞ntihar hamlesi yasak!", "#e74c3c");
              return false;
          }
          return true;
      };

      // --- DATA LOAD ---
      const savedData = app.getAttribute('data-problem');
      if (savedData) {
        try {
          const prob = JSON.parse(savedData);
          size = prob.size || 9;
          initStones(size);
          
          if (prob.turn) currentColor = prob.turn; else currentColor = 'black';

          if (prob.initialState) {
             initialStonesState = prob.initialState;
             const parsedState = JSON.parse(prob.initialState);
             if (Array.isArray(parsedState)) {
                if (Array.isArray(parsedState[0])) stones = parsedState;
                else (parsedState as any[]).forEach((s: any) => { if (s && s.x !== undefined) stones[s.x][s.y] = { color: s.color }; });
             }
          }
          if (prob.solution) {
              if (Array.isArray(prob.solution)) {
                  let ptr = moveTree;
                  prob.solution.forEach((move: any) => {
                      const newNode = { ...move, children: [], status: null };
                      ptr.children.push(newNode);
                      ptr = newNode;
                  });
                  ptr.status = 'correct';
              } else {
                  moveTree = prob.solution;
              }
          }
          currentNode = moveTree; 
          if (!isTeacher) mode = 'SOLVE';
        } catch (e) { console.error(e); }
      }

      // --- DRAW ---
      const drawBoard = () => {
        ctx.fillStyle = "#eebb66"; ctx.fillRect(0, 0, canvas.width, canvas.height);
        const cellSize = (canvas.width - padding * 2) / (size - 1);

        ctx.lineWidth = 1.5 * resolution; ctx.strokeStyle = '#000'; ctx.beginPath();
        for (let i = 0; i < size; i++) {
          const pos = Math.round(padding + i * cellSize);
          ctx.moveTo(pos, padding); ctx.lineTo(pos, canvas.height - padding);
          ctx.moveTo(padding, pos); ctx.lineTo(canvas.width - padding, pos);
          ctx.fillStyle = '#000'; ctx.font = `bold ${12 * resolution}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
          const label = String.fromCharCode(65 + (i >= 8 ? i + 1 : i));
          ctx.fillText(label, pos, canvas.height - (10 * resolution)); ctx.fillText((size - i).toString(), (15 * resolution), pos);
        }
        ctx.stroke();

        const hoshiCoords = size === 19 ? [3, 9, 15] : size === 13 ? [3, 6, 9] : [2, 4, 6];
        if (size >= 9) {
          ctx.fillStyle = '#000';
          hoshiCoords.forEach(hx => { hoshiCoords.forEach(hy => {
              ctx.beginPath(); ctx.arc(padding + hx * cellSize, padding + hy * cellSize, 3 * resolution, 0, Math.PI * 2); ctx.fill();
            }); });
        }

        stones.forEach((row: any, x) => row.forEach((stone: any, y) => { 
            if (stone) drawStone(x, y, stone.color, cellSize, 1); 
        }));

        if (hoverPos.x >= 0 && hoverPos.x < size && hoverPos.y >= 0 && hoverPos.y < size) {
          if (!stones[hoverPos.x][hoverPos.y]) {
            drawStone(hoverPos.x, hoverPos.y, currentColor, cellSize, 0.5);
          }
        }
      };

      const drawStone = (x, y, color, cellSize, opacity) => {
        const posX = padding + x * cellSize; const posY = padding + y * cellSize; const radius = cellSize * 0.48;
        ctx.save(); ctx.globalAlpha = opacity;
        if (opacity === 1) { ctx.shadowColor = "rgba(0,0,0,0.3)"; ctx.shadowBlur = 3 * resolution; ctx.shadowOffsetX = 1 * resolution; ctx.shadowOffsetY = 1 * resolution; }
        ctx.beginPath(); ctx.arc(posX, posY, radius, 0, Math.PI * 2);
        if (color === 'black') {
          const grad = ctx.createRadialGradient(posX - radius*0.3, posY - radius*0.3, radius*0.1, posX, posY, radius);
          grad.addColorStop(0, "#555"); grad.addColorStop(1, "#000"); ctx.fillStyle = grad;
        } else {
          const grad = ctx.createRadialGradient(posX - radius*0.3, posY - radius*0.3, radius*0.1, posX, posY, radius);
          grad.addColorStop(0, "#fff"); grad.addColorStop(1, "#ddd"); ctx.fillStyle = grad;
        }
        ctx.fill(); 
        if (color === 'white' && opacity === 1) { ctx.lineWidth = 1; ctx.strokeStyle = "#ccc"; ctx.stroke(); }
        ctx.restore();
      };

      // --- EVENTS ---
      canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height;
        const mouseX = (e.clientX - rect.left) * scaleX - padding;
        const mouseY = (e.clientY - rect.top) * scaleY - padding;
        const cellSize = (canvas.width - padding * 2) / (size - 1);
        const x = Math.round(mouseX / cellSize); const y = Math.round(mouseY / cellSize);
        if (x >= 0 && x < size && y >= 0 && y < size) { if (hoverPos.x !== x || hoverPos.y !== y) { hoverPos = { x, y }; canvas.style.cursor = 'pointer'; drawBoard(); } } 
        else { if (hoverPos.x !== -1) { hoverPos = { x: -1, y: -1 }; canvas.style.cursor = 'default'; drawBoard(); } }
      });
      canvas.addEventListener('mouseleave', () => { hoverPos = { x: -1, y: -1 }; drawBoard(); });

      // --- CLICK ---
      canvas.addEventListener('click', (e) => {
        if (hoverPos.x === -1) return;
        const x = hoverPos.x; const y = hoverPos.y;

        if (mode === 'SETUP') { 
            stones[x][y] = stones[x][y] && stones[x][y].color === currentColor ? null : { color: currentColor }; 
            drawBoard();
        } 
        else if (mode === 'RECORD') { 
            if (stones[x][y]) return; 
            const stateBeforeMove = JSON.stringify(stones);
            const colorBeforeMove = currentColor;

            if (!playMove(x, y, currentColor)) return;

            let existingChild = currentNode.children.find((child: any) => child.x === x && child.y === y);

            if (existingChild) {
                currentPathStack.push({ node: currentNode, stonesSnapshot: stateBeforeMove, turn: colorBeforeMove });
                currentNode = existingChild;
                updateStatusText(`Mevcut dalda ilerlendi.`, '#3498db');
            } else {
                const newNode = { x, y, color: currentColor, children: [], status: null };
                currentNode.children.push(newNode);
                currentPathStack.push({ node: currentNode, stonesSnapshot: stateBeforeMove, turn: colorBeforeMove });
                currentNode = newNode;
                updateStatusText("Yeni varyasyon kaydediliyor...", '#f1c40f');
            }
            currentColor = currentColor === 'black' ? 'white' : 'black';
            drawBoard();
        } 
        else if (mode === 'SOLVE') {
            const nextNode = currentNode.children.find((child: any) => child.x === x && child.y === y);

            if (nextNode) {
                playMove(x, y, nextNode.color);
                currentNode = nextNode;
                currentColor = currentColor === 'black' ? 'white' : 'black';
                drawBoard();
                checkNodeStatus(currentNode);

                if (currentNode.children.length > 0 && !currentNode.status) {
                    setTimeout(() => {
                        const responseNode = currentNode.children[0];
                        playMove(responseNode.x, responseNode.y, responseNode.color);
                        currentNode = responseNode;
                        currentColor = currentColor === 'black' ? 'white' : 'black';
                        drawBoard();
                        checkNodeStatus(currentNode);
                    }, 500); 
                }
            } else {
                updateStatusText("Tanƒ±msƒ±z hamle. (Yanlƒ±≈ü olabilir)", '#e74c3c');
                if (typeof (window as any).handleMoveResult === 'function') (window as any).handleMoveResult(false);
            }
        }
      });

      function checkNodeStatus(node) {
          if (node.status === 'correct') {
              updateStatusText("Tebrikler! Doƒüru √á√∂z√ºm.", '#2ecc71');
              if (typeof (window as any).handleMoveResult === 'function') (window as any).handleMoveResult(true);
              if (typeof (window as any).unlockNextButton === 'function') (window as any).unlockNextButton();
          } else if (node.status === 'wrong') {
              updateStatusText("Yanlƒ±≈ü yol! Ba≈üarƒ±sƒ±z.", '#e74c3c');
              if (typeof (window as any).handleMoveResult === 'function') (window as any).handleMoveResult(false);
          }
      }

      function updateStatusText(text, color) {
          if (statusDiv) { statusDiv.innerText = text; statusDiv.style.color = color; }
      }

      if (isTeacher) {
          app.querySelector('#undoBtn')?.addEventListener('click', () => {
              if (currentPathStack.length > 0) {
                  const lastStep = currentPathStack.pop();
                  currentNode = lastStep.node; 
                  stones = JSON.parse(lastStep.stonesSnapshot); 
                  currentColor = lastStep.turn;
                  updateStatusText("Geri alƒ±ndƒ±.", '#fff');
                  drawBoard();
              }
          });

          app.querySelector('#markCorrectBtn')?.addEventListener('click', () => {
              if (currentNode === moveTree) return;
              currentNode.status = 'correct';
              updateStatusText("Bu dal 'DOƒûRU' i≈üaretlendi.", '#2ecc71');
          });

          app.querySelector('#markWrongBtn')?.addEventListener('click', () => {
              if (currentNode === moveTree) return;
              currentNode.status = 'wrong';
              updateStatusText("Bu dal 'YANLI≈û' i≈üaretlendi.", '#e74c3c');
          });

          app.querySelector('.setupBtn')?.addEventListener('click', () => updateUI('SETUP'));
          app.querySelector('.recordBtn')?.addEventListener('click', () => updateUI('RECORD'));
          
          app.querySelector('.exportBtn')?.addEventListener('click', () => { 
            const data = { 
                id: `prob-${Date.now()}`, 
                size, 
                turn: recordingStartColor,
                initialState: initialStonesState || JSON.stringify(stones), 
                solution: moveTree 
            }; 
            console.log(JSON.stringify(data, null, 2)); alert("Aƒüa√ß yapƒ±sƒ± (Tree) Console'a yazdƒ±rƒ±ldƒ±!");
          });
          
          const colorBtn = app.querySelector('.colorToggleBtn');
          if(colorBtn) colorBtn.addEventListener('click', () => {
            currentColor = currentColor === 'black' ? 'white' : 'black';
            const indicator = document.getElementById('teacherColorIndicator');
            if(indicator) { indicator.classList.toggle('black'); indicator.classList.toggle('white'); }
          });
      }

      const updateUI = (newMode) => {
        if (newMode === 'SETUP') {
            if (initialStonesState) {
                const parsed = JSON.parse(initialStonesState);
                if(Array.isArray(parsed) && Array.isArray(parsed[0])) stones = parsed;
                moveTree = { children: [] };
                currentNode = moveTree;
                currentPathStack = [];
            }
            updateStatusText("Ta≈ülarƒ± dizin.", '#fff');
        }

        if (newMode === 'RECORD' && mode === 'SETUP') {
             initialStonesState = JSON.stringify(stones);
             recordingStartColor = currentColor; 
             moveTree = { children: [] }; 
             currentNode = moveTree;
             currentPathStack = [];
             updateStatusText("Kayƒ±t Ba≈üladƒ±.", '#f1c40f');
        }

        mode = newMode;
        app.querySelectorAll('.control-btn').forEach(btn => btn.classList.remove('active'));
        if(newMode === 'SETUP') app.querySelector('.setupBtn')?.classList.add('active');
        if(newMode === 'RECORD') app.querySelector('.recordBtn')?.classList.add('active');
      };

      app.querySelector('.resetBtn')?.addEventListener('click', () => {
         updateStatusText("", "#fff");
         if (isTeacher && mode === 'SETUP') { initStones(size); }
         else { 
             const probData = savedData ? JSON.parse(savedData) : {};
             if (probData.turn) currentColor = probData.turn; 
             else currentColor = 'black';

             if(initialStonesState) {
                 const parsed = JSON.parse(initialStonesState);
                 if(Array.isArray(parsed) && Array.isArray(parsed[0])) stones = parsed; 
                 else { initStones(size); if(Array.isArray(parsed)) (parsed as any[]).forEach((s: any) => {if(s) stones[s.x][s.y] = {color:s.color}}); }
             } else { initStones(size); }
             
             currentNode = moveTree; 
             currentPathStack = [];
         }
         drawBoard();
      });

      // --- EKLENEN KISIM: Global Reset Fonksiyonu ---
      // Dƒ±≈üarƒ±dan t√ºm boardlarƒ± sƒ±fƒ±rlamak i√ßin kullanƒ±lƒ±r.
      if (!(window as any).resetAllBoards) {
          (window as any).resetAllBoards = () => {
              const resetButtons = document.querySelectorAll('.resetBtn');
              resetButtons.forEach((btn) => {
                  if (btn instanceof HTMLElement) btn.click();
              });
          };
      }

      app.setAttribute('data-initialized', 'true');
      drawBoard();
    });
  };
  
  document.addEventListener('astro:page-load', setupBoard);
  document.addEventListener('DOMContentLoaded', setupBoard);
</script>