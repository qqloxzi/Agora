---
// components/goboard.astro
const { problem, isTeacher = false } = Astro.props;
---

<div class="go-app" data-problem={problem ? JSON.stringify(problem) : null} data-teacher={isTeacher.toString()}>
  
  {!isTeacher && problem && (
    <div class="top-info-bar">
      <div class="turn-badge">
        <div class={`turn-indicator ${problem.turn}`}></div>
        <span>{problem.turn === 'black' ? 'Siyah Hamlesi' : 'Beyaz Hamlesi'}</span>
      </div>
    </div>
  )}

  <div class="status"></div>

  <div class="go-wrapper-shadow">
      <div class="go-container">
        <div class="coords-layer"></div>
        <canvas class="goBoard"></canvas>
      </div>
  </div>

  <div class="bottom-controls">
    <slot name="external-controls" />

    {!isTeacher && (
      <button class="control-btn resetBtn tooltip" data-tip="Ba≈üa D√∂n">
        <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
      </button>
    )}

    {isTeacher && (
        <div class="teacher-group">
            <div class="size-selector">
                <button class="size-btn active" data-size="9">9</button>
                <button class="size-btn" data-size="13">13</button>
                <button class="size-btn" data-size="19">19</button>
            </div>
            <div class="divider"></div>
            <button class="control-btn lastMoveBtn tooltip" data-tip="Son Hamle">üë£</button>
            <button class="control-btn setupBtn tooltip" data-tip="Dizme">‚öôÔ∏è</button>
            <button class="control-btn recordBtn tooltip" data-tip="Kayƒ±t">‚è∫</button>
            <button class="control-btn exportBtn tooltip" data-tip="ƒ∞ndir">üíæ</button>
            <button class="control-btn colorToggleBtn tooltip" data-tip="Renk">
               <div class="turn-indicator black" id="teacherColorIndicator"></div>
            </button>
            <button class="control-btn resetBtn tooltip" data-tip="Temizle">‚Ü∫</button>
        </div>
    )}
  </div>
</div>

<style>
  :root { --status-text: #ffffff; }
  :global(body.light) .go-app { --status-text: #2c3e50; }
  
  .go-app { 
      display: flex; flex-direction: column; align-items: center; 
      width: 100%; max-width: 100%; padding: 0; position: relative;
  }
  
  .status { 
      font-size: 1rem; font-weight: 700; margin-bottom: 5px; min-height: 1.6em; 
      color: var(--status-text); text-align: center;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
  }

  .top-info-bar { margin-bottom: 8px; display: flex; justify-content: center; width: 100%; }
  
  .turn-badge { 
      display: flex; align-items: center; gap: 8px; 
      background: rgba(30, 40, 50, 0.85); 
      border: 1px solid rgba(255,255,255,0.15); 
      padding: 4px 16px; border-radius: 20px; 
      color: #ecf0f1; font-weight: 600; font-size: 0.85rem; 
      backdrop-filter: blur(4px); box-shadow: 0 2px 5px rgba(0,0,0,0.3);
  }

  /* --- B√úY√úT√úLM√ú≈û TAHTA ALANI --- */
  .go-wrapper-shadow {
      position: relative;
      border-radius: 3px;
      box-shadow: 0 15px 40px rgba(0,0,0,0.5);
      margin: 0 auto; 
      width: fit-content;
  }

  .go-container { 
      display: block; position: relative; z-index: 10;
      /* Mobilde ekranƒ± tam doldursun (%98), Masa√ºst√ºnde 650px'e kadar b√ºy√ºs√ºn */
      width: 98vw; max-width: 650px; aspect-ratio: 1 / 1; 
      border-radius: 3px;
      
      /* NET TURUNCU ZEMƒ∞N */
      background-color: #f2b06d; 
      background-image: linear-gradient(90deg, rgba(0,0,0,0.03) 0%, transparent 50%, rgba(0,0,0,0.03) 100%);
      border: 2px solid #5d3a1a; 
      box-sizing: border-box; 
  }

  /* Dikey ekranlarda (telefon) ta≈ümasƒ±n */
  @media (max-height: 700px) { .go-container { max-height: 70vh; width: auto; aspect-ratio: 1 / 1; } }
  
  canvas { display: block; width: 100% !important; height: 100% !important; touch-action: none; cursor: pointer; }

  /* --- KOORDƒ∞NATLAR (METƒ∞N OLARAK) --- */
  .coords-layer {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none; /* Tƒ±klamalar canvas'a ge√ßsin */
      z-index: 5;
  }
  
  /* Dinamik olarak eklenecek koordinat stilleri */
  :global(.coord-label) {
      position: absolute;
      font-family: 'Segoe UI', sans-serif;
      font-weight: 700;
      color: #3e2723; /* Koyu Ah≈üap Rengi */
      font-size: 14px; /* JS ile dinamik ayarlanabilir ama baz deƒüer */
      text-align: center;
      line-height: 1;
      transform: translate(-50%, -50%); /* Tam ortalamak i√ßin */
      text-shadow: 0 1px 0 rgba(255,255,255,0.3); /* Hafif kabartma */
  }

  /* --- KONTROL BAR --- */
  .bottom-controls { 
      margin-top: 15px; width: auto; 
      display: flex; justify-content: center; align-items: center; gap: 12px;
      background: rgba(20, 20, 20, 0.85); 
      padding: 10px 25px; border-radius: 30px;
      border: 1px solid rgba(255,255,255,0.1);
      backdrop-filter: blur(10px);
      box-shadow: 0 5px 20px rgba(0,0,0,0.4);
      max-width: 98vw;
      flex-wrap: wrap; /* K√º√ß√ºk ekranlarda sƒ±ƒümazsa alt satƒ±ra ge√ßsin */
  }

  .control-btn { 
      width: 46px; height: 46px; border-radius: 50%; 
      background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.15); 
      color: #ecf0f1; display: flex; align-items: center; justify-content: center; 
      cursor: pointer; transition: all 0.2s; flex-shrink: 0; 
  }
  .control-btn:hover { background: rgba(255,255,255,0.2); transform: translateY(-2px); color: #fff; }
  .control-btn:active { transform: scale(0.95); }
  
  .resetBtn:hover { background: rgba(231, 76, 60, 0.8); border-color: #c0392b; }
  .teacher-group { display: flex; gap: 6px; align-items: center; flex-wrap: wrap; justify-content: center; }
  .divider { width: 1px; height: 24px; background: rgba(255,255,255,0.2); margin: 0 4px; }
  
  .size-selector { display: flex; gap: 2px; }
  .size-btn { background: transparent; border: 1px solid rgba(255,255,255,0.2); color: #bdc3c7; border-radius: 4px; padding: 4px 8px; font-size: 0.8rem; cursor: pointer; }
  .size-btn.active { background: #3498db; color: #fff; border-color: #3498db; }

  .turn-indicator { width: 14px; height: 14px; border-radius: 50%; display: inline-block; box-shadow: 0 1px 3px rgba(0,0,0,0.5); }
  .turn-indicator.black { background: #000; border: 1px solid #555; }
  .turn-indicator.white { background: #fff; border: 1px solid #999; }
  
  .tooltip { position: relative; }
  .tooltip:hover::after { content: attr(data-tip); position: absolute; bottom: 130%; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.9); color: #fff; padding: 5px 10px; border-radius: 4px; font-size: 0.75rem; white-space: nowrap; pointer-events: none; opacity: 0; animation: fadeIn 0.2s forwards; z-index: 100; }
  @keyframes fadeIn { to { opacity: 1; } }
</style>

<script>
  const clickSound = new Audio('/sounds/stone.mp3');
  clickSound.volume = 0.8;

  const setupBoard = () => {
    document.querySelectorAll('.go-app').forEach(appElement => {
      const app = appElement as HTMLElement;
      if (app.getAttribute('data-initialized')) return;
      
      const canvas = app.querySelector('.goBoard') as HTMLCanvasElement;
      const coordsLayer = app.querySelector('.coords-layer') as HTMLElement;
      const statusDiv = app.querySelector('.status') as HTMLElement;
      if (!canvas) return;

      const isTeacher = app.getAttribute('data-teacher') === 'true';
      const ctx = canvas.getContext('2d', { alpha: false });
      if (!ctx) return;
      
      let size = 9; 
      const resolution = window.devicePixelRatio || 2; 
      const boardDisplaySize = 1000; 
      let padding = 0; 
      let mode = isTeacher ? 'SETUP' : 'SOLVE';

      let stones: any[][] = []; 
      let labels: any[][] = [];
      let boardHistory: any[] = [];
      let currentColor = 'black'; 
      let initialStonesState = ""; 
      let recordingStartColor = 'black'; 
      let moveTree: any = { children: [] }; 
      let currentNode: any = moveTree;      
      let currentPathStack: any[] = [];
      let hasSolution = false;
      let hoverPos = { x: -1, y: -1 };
      let isLocked = false;
      let lastMove: { x: number, y: number, color: string } | null = null;
      let isLastMoveMode = false;
      let isLabelMode = false; let labelCounter = 1;

      // --- KOORDƒ∞NATLARI HTML OLARAK √áƒ∞ZEN FONKSƒ∞YON ---
      const renderCoords = () => {
          if (!coordsLayer) return;
          coordsLayer.innerHTML = ''; 

          const rect = canvas.getBoundingClientRect();
          const displayW = rect.width;
          const totalUnits = boardDisplaySize; 
          const paddingUnits = 60; 
          
          const scale = displayW / totalUnits;
          const displayPadding = paddingUnits * scale;
          const displayCellSize = (displayW - (displayPadding * 2)) / (size - 1);
          const fontSize = Math.max(10, displayCellSize * 0.35); 

          for(let i=0; i<size; i++) {
              const el = document.createElement('span');
              el.className = 'coord-label';
              el.innerText = String.fromCharCode(65 + (i >= 8 ? i + 1 : i)); 
              el.style.fontSize = `${fontSize}px`;
              el.style.left = `${displayPadding + (i * displayCellSize)}px`;
              el.style.top = `${displayPadding * 0.4}px`; 
              coordsLayer.appendChild(el);
          }

          for(let i=0; i<size; i++) {
              const el = document.createElement('span');
              el.className = 'coord-label';
              el.innerText = (size - i).toString();
              el.style.fontSize = `${fontSize}px`;
              el.style.left = `${displayPadding * 0.4}px`; 
              el.style.top = `${displayPadding + (i * displayCellSize)}px`;
              coordsLayer.appendChild(el);
          }
      };

      const updateCanvasSize = () => {
          canvas.width = boardDisplaySize * resolution; 
          canvas.height = boardDisplaySize * resolution;
          padding = 60 * resolution; 
          requestAnimationFrame(renderCoords);
      };
      
      const resizeObserver = new ResizeObserver(() => { renderCoords(); });
      resizeObserver.observe(canvas);
      
      updateCanvasSize();
      const initStones = (s: number) => { stones = Array(s).fill(0).map(() => Array(s).fill(null)); labels = Array(s).fill(0).map(() => Array(s).fill(null)); };

      const safeUnlock = () => {
        window.dispatchEvent(new CustomEvent('unlock-next-problem'));
        setTimeout(() => {
           app.querySelectorAll('.next-btn, #nextBtn').forEach(btn => {
               if(btn instanceof HTMLButtonElement) { btn.disabled = false; btn.style.opacity = "1"; btn.style.cursor = "pointer"; btn.classList.add('glow-animation'); }
           });
        }, 100);
        try { if ((window as any).handleMoveResult) (window as any).handleMoveResult(true); } catch(e) {}
      };

      function updateStatusText(text: string, color: string) { if (statusDiv) { statusDiv.innerText = text; statusDiv.style.color = color; } }

      const animateLastMove = () => {
          if (!lastMove) return; const { x, y, color } = lastMove;
          if (!stones[x][y] && !isTeacher) stones[x][y] = { color };
          const originalStone = stones[x][y]; stones[x][y] = null; drawBoard(); 
          setTimeout(() => { stones[x][y] = originalStone; if (clickSound) { clickSound.currentTime = 0; clickSound.play().catch(()=>{}); } drawBoard(); }, 600); 
      };

      // --- DATA LOADING ---
      const savedData = app.getAttribute('data-problem');
      if (savedData) {
        try {
          const prob = JSON.parse(savedData);
          size = prob.size || 9; initStones(size);
          if (prob.labels) labels = typeof prob.labels === 'string' ? JSON.parse(prob.labels) : prob.labels;
          currentColor = prob.turn || 'black';
          lastMove = prob.lastMove || null;
          if (prob.initialState) {
             initialStonesState = prob.initialState; const parsed = JSON.parse(prob.initialState);
             if (Array.isArray(parsed) && Array.isArray(parsed[0])) stones = parsed;
             else if(Array.isArray(parsed)) parsed.forEach((s:any)=> {if(s) stones[s.x][s.y]={color:s.color}});
          }
          if (prob.solution) {
              if (Array.isArray(prob.solution) && prob.solution.length > 0) {
                  let ptr = moveTree; prob.solution.forEach((move: any) => { const n={...move, children:[], status:null}; ptr.children.push(n); ptr=n; });
                  ptr.status = 'correct'; hasSolution = true;
              } else if (prob.solution.children && prob.solution.children.length > 0) { moveTree = prob.solution; hasSolution = true; } 
              else { hasSolution = false; }
          } else { hasSolution = false; }
          currentNode = moveTree; 
          if (!isTeacher) { mode = 'SOLVE'; if (lastMove) setTimeout(animateLastMove, 300); }
        } catch (e) { console.error(e); }
      } else { initStones(size); hasSolution = false; }

      if (!isTeacher && !hasSolution) { setTimeout(() => { updateStatusText("Analiz Modu", '#3498db'); safeUnlock(); }, 100); }

      const changeBoardSize = (newSize: number) => {
          size = newSize; initStones(size); moveTree = { children: [] }; currentNode = moveTree; currentPathStack = []; initialStonesState = ""; currentColor = 'black'; lastMove = null;
          app.querySelectorAll('.size-btn').forEach(btn => {
              if(btn.getAttribute('data-size') == String(newSize)) btn.classList.add('active'); else btn.classList.remove('active');
          });
          drawBoard(); renderCoords(); updateStatusText(`${size}x${size} Tahta`, '#fff');
      };
      if (isTeacher) app.querySelectorAll('.size-btn').forEach(btn => btn.addEventListener('click', (e) => changeBoardSize(parseInt((e.target as HTMLElement).getAttribute('data-size') || "9"))));

      const isOnBoard = (x: number, y: number) => x >= 0 && x < size && y >= 0 && y < size;
      const getLiberties = (x: number, y: number, color: string, checked = new Set()) => {
          const key = `${x},${y}`; if (checked.has(key)) return 0; checked.add(key); let lib = 0;
          [[x+1, y], [x-1, y], [x, y+1], [x, y-1]].forEach(([nx, ny]) => {
              if (isOnBoard(nx, ny)) { if (!stones[nx][ny]) lib++; else if (stones[nx][ny].color === color) lib += getLiberties(nx, ny, color, checked); }
          }); return lib;
      };
      const removeGroup = (x: number, y: number, color: string) => {
          const stone = stones[x][y]; if (!stone || stone.color !== color) return; stones[x][y] = null;
          [[x+1, y], [x-1, y], [x, y+1], [x, y-1]].forEach(([nx, ny]) => { if (isOnBoard(nx, ny)) removeGroup(nx, ny, color); });
      };
      const playMove = (x: number, y: number, color: string) => {
        if (stones[x][y]) return false; const orig = JSON.stringify(stones); stones[x][y] = { color };
        let caps = false; const opp = color === 'black' ? 'white' : 'black';
        [[x+1, y], [x-1, y], [x, y+1], [x, y-1]].forEach(([nx, ny]) => {
            if (isOnBoard(nx, ny) && stones[nx][ny] && stones[nx][ny].color === opp && getLiberties(nx, ny, opp) === 0) { removeGroup(nx, ny, opp); caps = true; }
        });
        if (!caps && getLiberties(x, y, color) === 0) { stones = JSON.parse(orig); updateStatusText("ƒ∞ntihar Yasak!", "#e74c3c"); return false; }
        const newState = JSON.stringify(stones);
        if (boardHistory.length > 0 && boardHistory[boardHistory.length - 1] === newState) { stones = JSON.parse(orig); updateStatusText("Ko!", "#e74c3c"); return false; }
        boardHistory.push(orig); if (boardHistory.length > 2) boardHistory.shift(); 
        if (clickSound) { clickSound.currentTime = 0; clickSound.play().catch(()=>{}); } return true;
      };

      const drawBoard = () => {
        if (!canvas) return; 
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#f2b06d"; ctx.fillRect(0, 0, canvas.width, canvas.height);

        const cellSize = (canvas.width - padding * 2) / (size - 1);

        // Grid
        ctx.lineWidth = 1.1 * resolution; ctx.strokeStyle = '#2b1d0e'; ctx.beginPath();
        for (let i = 0; i < size; i++) {
          const pos = Math.round(padding + i * cellSize) + 0.5;
          ctx.moveTo(pos, padding); ctx.lineTo(pos, canvas.height - padding);
          ctx.moveTo(padding, pos); ctx.lineTo(canvas.width - padding, pos);
        }
        ctx.stroke();

        // Hoshi
        const hoshi = size === 19 ? [3, 9, 15] : size === 13 ? [3, 6, 9] : [2, 4, 6];
        if (size >= 9) {
          ctx.fillStyle = '#000';
          hoshi.forEach(hx => { hoshi.forEach(hy => {
              ctx.beginPath(); ctx.arc(Math.round(padding + hx * cellSize), Math.round(padding + hy * cellSize), 3 * resolution, 0, Math.PI * 2); ctx.fill();
          }); });
        }
        
        ctx.fillStyle = "#000"; ctx.font = `bold ${cellSize * 0.5}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        for (let x = 0; x < size; x++) for (let y = 0; y < size; y++) if (labels[x][y]) ctx.fillText(labels[x][y], padding + x * cellSize, padding + y * cellSize);

        stones.forEach((row, x) => row.forEach((st: any, y: number) => { if (st) drawStone(x, y, st.color, cellSize, 1); }));

        if (lastMove && stones[lastMove.x][lastMove.y]) {
            const posX = padding + lastMove.x * cellSize; const posY = padding + lastMove.y * cellSize;
            const mc = stones[lastMove.x][lastMove.y].color === 'black' ? 'rgba(255,255,255,0.9)' : 'rgba(0,0,0,0.9)';
            ctx.beginPath(); ctx.arc(posX, posY, cellSize * 0.12, 0, 2 * Math.PI); ctx.fillStyle = mc; ctx.fill();
        }
        if (!isLocked && hoverPos.x >= 0 && hoverPos.x < size && hoverPos.y >= 0 && hoverPos.y < size && !stones[hoverPos.x][hoverPos.y]) {
            drawStone(hoverPos.x, hoverPos.y, currentColor, cellSize, 0.5);
        }
      };

      const drawStone = (x: number, y: number, color: string, cellSize: number, opacity: number) => {
        const posX = Math.round(padding + x * cellSize); const posY = Math.round(padding + y * cellSize); const radius = cellSize * 0.48;
        ctx.save(); ctx.globalAlpha = opacity;
        if (opacity === 1) { ctx.shadowColor = "rgba(0,0,0,0.3)"; ctx.shadowBlur = 4 * resolution; ctx.shadowOffsetX = 1.5 * resolution; ctx.shadowOffsetY = 1.5 * resolution; }
        ctx.beginPath(); ctx.arc(posX, posY, radius, 0, Math.PI * 2);
        if (color === 'black') {
          const g = ctx.createRadialGradient(posX - radius*0.3, posY - radius*0.3, radius*0.1, posX, posY, radius);
          g.addColorStop(0, "#666"); g.addColorStop(0.3, "#222"); g.addColorStop(1, "#000"); ctx.fillStyle = g;
        } else {
          const g = ctx.createRadialGradient(posX - radius*0.3, posY - radius*0.4, radius*0.05, posX, posY, radius);
          g.addColorStop(0, "#fff"); g.addColorStop(0.5, "#f0f0f0"); g.addColorStop(1, "#ccc"); ctx.fillStyle = g;
        }
        ctx.fill(); 
        if (color === 'white' && opacity === 1) { ctx.shadowColor="transparent"; ctx.lineWidth=0.5 * resolution; ctx.strokeStyle="rgba(0,0,0,0.2)"; ctx.stroke(); }
        ctx.restore();
      };

      canvas.addEventListener('mousemove', (e) => {
        if (mode === 'SOLVE' && isLocked) { canvas.style.cursor = 'default'; return; }
        const r = canvas.getBoundingClientRect();
        const mouseX = (e.clientX - r.left) * (canvas.width / r.width) - padding;
        const mouseY = (e.clientY - r.top) * (canvas.height / r.height) - padding;
        const cs = (canvas.width - padding * 2) / (size - 1);
        const x = Math.round(mouseX / cs); const y = Math.round(mouseY / cs);
        if (isOnBoard(x, y)) { if (hoverPos.x !== x || hoverPos.y !== y) { hoverPos = { x, y }; canvas.style.cursor = 'pointer'; drawBoard(); } } 
        else if (hoverPos.x !== -1) { hoverPos = { x: -1, y: -1 }; canvas.style.cursor = 'default'; drawBoard(); }
      });
      canvas.addEventListener('mouseleave', () => { hoverPos = { x: -1, y: -1 }; drawBoard(); });

      canvas.addEventListener('click', () => {
        if (mode === 'SOLVE' && isLocked) { updateStatusText("Tekrar deneyin", '#e74c3c'); return; }
        if (hoverPos.x === -1) return; const {x,y} = hoverPos;
        if (isLastMoveMode) { if(stones[x][y]) { lastMove={x,y,color:stones[x][y].color}; drawBoard(); updateStatusText("ƒ∞≈üaretlendi", '#2ecc71'); } return; }
        if (stones[x][y]) return;
        if (isLabelMode) { labels[x][y] = labels[x][y] ? null : labelCounter++; drawBoard(); return; }

        if (mode === 'SETUP') { stones[x][y] = (!stones[x][y] || stones[x][y].color !== currentColor) ? {color:currentColor} : null; drawBoard(); }
        else if (mode === 'RECORD') {
             if (stones[x][y]) return; const prev = JSON.stringify(stones); const t = currentColor;
             if (!playMove(x, y, currentColor)) return;
             const ch = currentNode.children.find((c:any)=>c.x===x && c.y===y);
             if(ch) { currentPathStack.push({node:currentNode, stonesSnapshot:prev, turn:t}); currentNode=ch; updateStatusText("Mevcut Dal", '#3498db'); }
             else { const n = {x,y,color:currentColor, children:[], status:null}; currentNode.children.push(n); currentPathStack.push({node:currentNode, stonesSnapshot:prev, turn:t}); currentNode=n; updateStatusText("Yeni Varyasyon", '#f1c40f'); }
             currentColor = currentColor === 'black' ? 'white' : 'black'; drawBoard();
        }
        else if (mode === 'SOLVE') {
             if (!hasSolution) { if(playMove(x,y,currentColor)) { currentColor=currentColor==='black'?'white':'black'; drawBoard(); } return; }
             const next = currentNode.children.find((c:any)=>c.x===x && c.y===y);
             if (next) {
                 playMove(x, y, next.color); currentNode = next; currentColor = currentColor==='black'?'white':'black'; drawBoard(); checkNodeStatus(currentNode);
                 if (currentNode.children?.length && !currentNode.status) {
                     setTimeout(() => {
                         const rnd = currentNode.children[Math.floor(Math.random()*currentNode.children.length)];
                         playMove(rnd.x, rnd.y, rnd.color); currentNode=rnd; currentColor=currentColor==='black'?'white':'black'; drawBoard(); checkNodeStatus(currentNode);
                     }, 500);
                 }
             } else { updateStatusText("Yanlƒ±≈ü Hamle", '#e74c3c'); isLocked=true; app.classList.add('locked'); if((window as any).handleMoveResult) (window as any).handleMoveResult(false); }
        }
      });
      
      const checkNodeStatus = (n: any) => { if(n.status==='correct') finalizeSuccess(); else if(n.status==='wrong') finalizeFail(); else if(!n.children?.length) finalizeSuccess(); };
      const finalizeSuccess = () => { updateStatusText("Tebrikler!", '#2ecc71'); isLocked=true; app.classList.add('locked'); safeUnlock(); };
      const finalizeFail = () => { updateStatusText("Yanlƒ±≈ü Yol", '#e74c3c'); isLocked=true; app.classList.add('locked'); if((window as any).handleMoveResult) (window as any).handleMoveResult(false); };

      // --- EKSƒ∞K OLAN UPDATEUI FONKSƒ∞YONU GERƒ∞ EKLENDƒ∞ ---
      const updateUI = (newMode: string) => {
        if (newMode === 'SETUP') { 
            if (initialStonesState) { 
                const parsed = JSON.parse(initialStonesState); 
                if(Array.isArray(parsed) && Array.isArray(parsed[0])) stones = parsed; 
                moveTree = { children: [] }; currentNode = moveTree; currentPathStack = []; 
            } 
            updateStatusText("Ta≈ülarƒ± dizin.", '#fff'); 
        }
        if (newMode === 'RECORD' && mode === 'SETUP') { 
            initialStonesState = JSON.stringify(stones); 
            recordingStartColor = currentColor; 
            moveTree = { children: [] }; 
            currentNode = moveTree; 
            currentPathStack = []; 
            updateStatusText("Kayƒ±t Ba≈üladƒ±.", '#f1c40f'); 
        }
        mode = newMode; 
        app.querySelectorAll('.control-btn').forEach(btn => btn.classList.remove('active'));
        if(newMode === 'SETUP') app.querySelector('.setupBtn')?.classList.add('active'); 
        if(newMode === 'RECORD') app.querySelector('.recordBtn')?.classList.add('active');
      };

      if (isTeacher) {
          app.querySelector('.resetBtn')?.addEventListener('click', ()=>{ stones=Array(size).fill(0).map(()=>Array(size).fill(null)); drawBoard(); });
          app.querySelector('.setupBtn')?.addEventListener('click', ()=>updateUI('SETUP'));
          app.querySelector('.recordBtn')?.addEventListener('click', ()=>updateUI('RECORD'));
          app.querySelector('.exportBtn')?.addEventListener('click', () => { 
             const t = prompt("Ba≈ülƒ±k")||"Soru"; const d={id:`p-${Date.now()}`, size, turn:recordingStartColor, title:t, initialState:initialStonesState||JSON.stringify(stones), solution:moveTree}; console.log(JSON.stringify(d)); alert("Konsola yazƒ±ldƒ±");
          });
          app.querySelector('.colorToggleBtn')?.addEventListener('click', () => { currentColor=currentColor==='black'?'white':'black'; document.getElementById('teacherColorIndicator')?.classList.toggle('black'); document.getElementById('teacherColorIndicator')?.classList.toggle('white'); });
      }
      
      app.querySelector('.resetBtn')?.addEventListener('click', () => { 
          updateStatusText("", "#fff"); isLocked=false; app.classList.remove('locked'); hoverPos={x:-1,y:-1}; boardHistory=[];
          if(!isTeacher && savedData) {
              const p=JSON.parse(savedData); currentColor=p.turn||'black'; 
              if(p.initialState) { const ps=JSON.parse(p.initialState); if(Array.isArray(ps[0])) stones=ps; } else initStones(size);
              currentNode=moveTree; currentPathStack=[]; if(lastMove) setTimeout(animateLastMove, 300);
          }
          drawBoard();
      });
      
      app.setAttribute('data-initialized', 'true');
      updateCanvasSize(); 
    }); 
  };
  
  document.addEventListener('astro:page-load', setupBoard);
  document.addEventListener('DOMContentLoaded', setupBoard);
</script>