---
// components/goboard.astro
const { problem, isTeacher = false } = Astro.props;
---

<div class="go-app" data-problem={problem ? JSON.stringify(problem) : null} data-teacher={isTeacher.toString()}>
  <div class="controls">
    {isTeacher ? (
      <>
        <div class="teacher-tools">
          <select class="boardSizeSelect">
            <option value="9">9x9 Board</option>
            <option value="13">13x13 Board</option>
            <option value="19">19x19 Board</option>
          </select>
          <button class="colorToggleBtn active-black">Current: Black</button>
        </div>
        <div class="action-buttons">
          <button class="setupBtn active">1. Setup Layout</button>
          <button class="recordBtn">2. Record Solution</button>
          <button class="exportBtn" style="background: #2ecc71; color: white;">Export JSON</button>
          <button class="resetBtn" style="background: #e74c3c; color: white; border-color: #c0392b;">Clear All</button>
        </div>
      </>
    ) : (
      <>
        <button class="resetBtn">Restart Problem</button>
      </>
    )}
  </div>
  
  <div class="status">Mode: {isTeacher ? 'Setup' : 'Solve this problem!'}</div>

  <div class="go-container">
    <canvas class="goBoard" width="550" height="550"></canvas>
  </div>
</div>

<style>
  .go-app { text-align: center; margin-bottom: 2rem; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
  .controls { display: flex; flex-direction: column; gap: 12px; margin-bottom: 20px; align-items: center; }
  .teacher-tools, .action-buttons { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
  
  button, select {
    padding: 10px 18px;
    cursor: pointer;
    border: 2px solid #bdc3c7;
    background: #fff;
    border-radius: 6px;
    font-weight: 600;
    transition: all 0.2s ease;
  }
  
  .colorToggleBtn.active-black { background: #2c3e50; color: #fff; border-color: #000; }
  .colorToggleBtn.active-white { background: #ecf0f1; color: #2c3e50; border-color: #bdc3c7; }
  
  button.active { background: #f39c12; color: white; border-color: #e67e22; }
  
  .go-container { 
    display: inline-flex; 
    padding: 10px; /* Kenar boşluğu azaltıldı */
    background-color: #eebb66; /* Daha doğal ahşap tonu */
    border-radius: 8px; 
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    border: 1px solid #d4a753;
  }
  
  canvas { cursor: none; /* Default cursor gizlendi, kendi çizimimizi kullanacağız */ display: block; }
  .status { font-size: 1.1rem; font-weight: bold; margin-bottom: 15px; color: #2c3e50; height: 1.5em; }
</style>

<script>
  const setupBoard = () => {
    document.querySelectorAll('.go-app').forEach(app => {
      if (app.getAttribute('data-initialized')) return;
      
      const canvas = app.querySelector('.goBoard') as HTMLCanvasElement;
      const statusDiv = app.querySelector('.status') as HTMLElement;
      const isTeacher = app.getAttribute('data-teacher') === 'true';
      const ctx = canvas.getContext('2d');
      if (!ctx) return;

      // --- AYARLAR ---
      let size = 9; 
      let padding = 30; // Boşluk azaltıldı (Eskisi 45 idi)
      // ---------------

      let mode = isTeacher ? 'SETUP' : 'SOLVE';
      let currentColor: 'black' | 'white' = 'black';
      let stones: any[][] = [];
      let solution: any[] = [];
      let solveIndex = 0;
      let initialStonesState = "";
      
      // Mouse Takibi için
      let hoverPos = { x: -1, y: -1 };

      const initStones = (newSize) => {
        stones = Array(newSize).fill(null).map(() => Array(newSize).fill(null));
      };

      initStones(size);

      const savedData = app.getAttribute('data-problem');
      if (savedData) {
        const prob = JSON.parse(savedData);
        size = prob.size || 9;
        initStones(size);
        initialStonesState = prob.initialState;
        stones = JSON.parse(initialStonesState);
        solution = prob.solution;
        if (!isTeacher) mode = 'SOLVE';
      }

      const drawBoard = () => {
        const cellSize = (canvas.width - padding * 2) / (size - 1);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // 1. Ahşap Zemin Dokusu (Hafif Gradyan)
        const grd = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        grd.addColorStop(0, "#f5cf7c");
        grd.addColorStop(1, "#eebb66");
        ctx.fillStyle = grd;
        ctx.fillRect(0,0, canvas.width, canvas.height);

        // 2. Çizgiler
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#000';
        
        ctx.beginPath();
        for (let i = 0; i < size; i++) {
          const pos = Math.round(padding + i * cellSize) + 0.5; // +0.5 keskin çizgiler için
          
          // Dikey
          ctx.moveTo(pos, padding); 
          ctx.lineTo(pos, canvas.height - padding);
          
          // Yatay
          ctx.moveTo(padding, pos); 
          ctx.lineTo(canvas.width - padding, pos);
          
          // Koordinat Yazıları
          ctx.fillStyle = '#443322'; 
          ctx.font = `bold ${size > 13 ? '10px' : '12px'} sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          
          // Harfler (Altta)
          const label = String.fromCharCode(65 + (i >= 8 ? i + 1 : i)); // I harfini atla
          ctx.fillText(label, pos, canvas.height - 10);
          
          // Sayılar (Solda)
          ctx.fillText((size - i).toString(), 15, pos);
        }
        ctx.stroke();

        // 3. Yıldız Noktaları (Hoshi)
        const hoshiCoords = size === 19 ? [3, 9, 15] : size === 13 ? [3, 6, 9] : [2, 4, 6];
        if (size >= 9) {
          hoshiCoords.forEach(hx => {
            hoshiCoords.forEach(hy => {
              ctx.beginPath();
              ctx.arc(padding + hx * cellSize, padding + hy * cellSize, 3.5, 0, Math.PI * 2);
              ctx.fillStyle = '#000';
              ctx.fill();
            });
          });
        }

        // 4. Taşları Çiz
        stones.forEach((row, x) => row.forEach((stone, y) => {
          if (stone) drawStone(x, y, stone.color, cellSize, 1);
        }));

        // 5. GHOST STONE (Önizleme Taşı)
        if (hoverPos.x >= 0 && hoverPos.x < size && hoverPos.y >= 0 && hoverPos.y < size) {
          // Sadece boş kareye ve geçerli bir moda önizleme çiz
          if (!stones[hoverPos.x][hoverPos.y]) {
            let ghostColor = currentColor;
            
            // Eğer SOLVE modundaysak, sıradaki hamlenin rengini veya kullanıcının oynaması gereken rengi tahmin et
            if (mode === 'SOLVE') {
               // Normalde çözümdeki sıradaki rengi gösteririz
               if (solution[solveIndex]) {
                 ghostColor = solution[solveIndex].color;
               } else {
                 // Çözüm bittiyse veya kayıt yoksa varsayılan
                 ghostColor = 'black'; 
               }
            }

            drawStone(hoverPos.x, hoverPos.y, ghostColor, cellSize, 0.5); // 0.5 Opacity
          }
        }
      };

      // Yardımcı Taş Çizme Fonksiyonu
      const drawStone = (x, y, color, cellSize, opacity) => {
        const posX = padding + x * cellSize;
        const posY = padding + y * cellSize;
        const radius = cellSize * 0.48; // Taşlar birbirine çok yakın olsun

        ctx.save();
        ctx.globalAlpha = opacity;
        
        ctx.beginPath();
        ctx.arc(posX, posY, radius, 0, Math.PI * 2);

        // Taş Gölgelendirmesi (Hafif 3D efekti)
        if (color === 'black') {
          const grad = ctx.createRadialGradient(posX - radius/3, posY - radius/3, radius/5, posX, posY, radius);
          grad.addColorStop(0, "#555");
          grad.addColorStop(1, "#000");
          ctx.fillStyle = grad;
        } else {
          const grad = ctx.createRadialGradient(posX - radius/3, posY - radius/3, radius/5, posX, posY, radius);
          grad.addColorStop(0, "#fff");
          grad.addColorStop(1, "#ddd");
          ctx.fillStyle = grad;
          ctx.strokeStyle = '#aaa'; 
          ctx.lineWidth = 1;
          ctx.stroke();
        }
        
        ctx.fill();
        ctx.restore();
      };

      // --- Event Listeners ---

      canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        const cellSize = (canvas.width - padding * 2) / (size - 1);
        
        // Mouse'un tam koordinatlarını al
        const mouseX = e.clientX - rect.left - padding;
        const mouseY = e.clientY - rect.top - padding;
        
        // En yakın ızgara noktasına yuvarla
        const x = Math.round(mouseX / cellSize);
        const y = Math.round(mouseY / cellSize);

        // Grid içinde mi kontrol et
        if (x >= 0 && x < size && y >= 0 && y < size) {
            // Sadece koordinat değiştiyse yeniden çiz (Performans için)
            if (hoverPos.x !== x || hoverPos.y !== y) {
                hoverPos = { x, y };
                canvas.style.cursor = 'pointer';
                drawBoard();
            }
        } else {
            if (hoverPos.x !== -1) {
                hoverPos = { x: -1, y: -1 };
                canvas.style.cursor = 'default';
                drawBoard();
            }
        }
      });

      canvas.addEventListener('mouseleave', () => {
        hoverPos = { x: -1, y: -1 };
        drawBoard();
      });

      canvas.addEventListener('click', (e) => {
        const cellSize = (canvas.width - padding * 2) / (size - 1);
        const rect = canvas.getBoundingClientRect();
        const x = Math.round((e.clientX - rect.left - padding) / cellSize);
        const y = Math.round((e.clientY - rect.top - padding) / cellSize);
        
        if (x < 0 || x >= size || y < 0 || y >= size) return;

        if (mode === 'SETUP') {
          stones[x][y] = stones[x][y] && stones[x][y].color === currentColor ? null : { color: currentColor };
        } else if (mode === 'RECORD') {
          if (!stones[x][y]) {
            stones[x][y] = { color: currentColor };
            solution.push({ x, y, color: currentColor });
          }
        } else if (mode === 'SOLVE') {
          const move = solution[solveIndex];
          if (move && x === move.x && y === move.y) {
            stones[x][y] = { color: move.color };
            solveIndex++;
            
            if (solveIndex === solution.length) {
              statusDiv.innerText = "CORRECT!";
              if (typeof (window as any).unlockNextButton === 'function') {
                  (window as any).unlockNextButton();
              } else {
                  console.error("unlockNextButton fonksiyonu bulunamadı!");
              }
            } else {
              statusDiv.innerText = "Good! Next...";
            }
          } else {
            statusDiv.innerText = "WRONG MOVE!";
             // İsteğe bağlı: Yanlış hamle efekti eklenebilir
          }
        }
        drawBoard();
      });

      // Öğretmen Modu Kontrolleri
      if (isTeacher) {
        const sizeSelect = app.querySelector('.boardSizeSelect') as HTMLSelectElement;
        sizeSelect.addEventListener('change', (e) => {
          size = parseInt((e.target as HTMLSelectElement).value);
          initStones(size);
          drawBoard();
        });

        const colorBtn = app.querySelector('.colorToggleBtn');
        colorBtn?.addEventListener('click', () => {
          currentColor = currentColor === 'black' ? 'white' : 'black';
          colorBtn.textContent = `Current: ${currentColor.charAt(0).toUpperCase() + currentColor.slice(1)}`;
          colorBtn.classList.toggle('active-black');
          colorBtn.classList.toggle('active-white');
        });
      }

      // Mod Değişimleri ve Butonlar
      const updateUI = (newMode) => {
        mode = newMode;
        app.querySelectorAll('.action-buttons button').forEach(btn => btn.classList.remove('active'));
        if (mode === 'SOLVE') {
          stones = JSON.parse(initialStonesState || JSON.stringify(stones));
          solveIndex = 0;
          statusDiv.innerText = "Mode: Solve this problem!";
        } else if (mode === 'RECORD') {
          initialStonesState = JSON.stringify(stones);
          solution = [];
          statusDiv.innerText = "Mode: Recording Solution Moves";
        } else {
          statusDiv.innerText = "Mode: Setup Layout";
        }
        drawBoard();
      };

      app.querySelector('.setupBtn')?.addEventListener('click', () => updateUI('SETUP'));
      app.querySelector('.recordBtn')?.addEventListener('click', () => updateUI('RECORD'));
      app.querySelector('.exportBtn')?.addEventListener('click', () => {
        if (solution.length === 0) return alert("Record a solution first!");
        const data = { id: `prob-${Date.now()}`, size, initialState: initialStonesState, solution };
        console.log(JSON.stringify(data, null, 2));
        alert("JSON Console'a yazdırıldı!");
      });

      app.querySelector('.resetBtn')?.addEventListener('click', () => {
         if (isTeacher && mode === 'SETUP') {
           initStones(size);
           solution = [];
         } else {
           stones = JSON.parse(initialStonesState || JSON.stringify(stones));
           solveIndex = 0;
           statusDiv.innerText = "Mode: Solve this problem!";
         }
         drawBoard();
      });

      app.setAttribute('data-initialized', 'true');
      drawBoard();
    });
  };

  document.addEventListener('astro:page-load', setupBoard);
  document.addEventListener('DOMContentLoaded', setupBoard);
</script>