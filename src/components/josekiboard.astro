---
// components/goboard.astro
const { problem, isTeacher = false, isJoseki = false } = Astro.props;
---

<div class="go-app" 
     data-problem={problem ? JSON.stringify(problem) : null} 
     data-teacher={isTeacher.toString()}
     data-joseki={isJoseki.toString()}>
  
  {!isTeacher && problem && (
    <div class="top-info-bar">
      <div class="turn-badge">
        <div class={`turn-indicator ${problem.turn}`}></div>
        <span>{problem.turn === 'black' ? 'Siyah Oynar' : 'Beyaz Oynar'}</span>
      </div>
    </div>
  )}

  <div class="status"></div>

  <div class="go-container">
    <canvas class="goBoard"></canvas>
  </div>

  <div class="bottom-controls">
    
    {!isTeacher && (
      <button class="control-btn resetBtn tooltip" data-tip="Ba≈üa D√∂n / Sƒ±fƒ±rla">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
      </button>
    )}

    {isTeacher && (
        <div class="teacher-group">
            <div class="size-selector">
                <button class="size-btn" data-size="9">9x9</button>
                <button class="size-btn" data-size="13">13x13</button>
                <button class="size-btn active" data-size="19">19x19</button>
                <button class="control-btn labelBtn tooltip" data-tip="Numara Ekle (1-2-3)">
                    <span style="font-weight:bold; font-size: 0.9em;">123</span>
                </button>
            </div>
            <div class="divider"></div>
            <button class="control-btn tooltip" id="undoBtn" data-tip="Geri Al">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 14 4 9l5-5"/><path d="M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5v0a5.5 5.5 0 0 1-5.5 5.5H11"/></svg>
            </button>
            <button class="control-btn tooltip" id="markCorrectBtn" data-tip="DOƒûRU Yol" style="color: #2ecc71; border-color: rgba(46, 204, 113, 0.5);">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg>
            </button>
            <button class="control-btn tooltip" id="markWrongBtn" data-tip="YANLI≈û Yol" style="color: #e74c3c; border-color: rgba(231, 76, 60, 0.5);">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
            </button>
            <div class="divider"></div>
            <button class="control-btn setupBtn tooltip" data-tip="Kurulum (Dizme)">‚öôÔ∏è</button>
            <button class="control-btn recordBtn tooltip" data-tip="Kayƒ±t Ba≈ülat">‚è∫</button>
            <button class="control-btn exportBtn tooltip" data-tip="JSON ƒ∞ndir">üíæ</button>
            <button class="control-btn colorToggleBtn tooltip" data-tip="Renk Deƒüi≈ütir">
               <div class="turn-indicator black" id="teacherColorIndicator"></div>
            </button>
            <div class="divider"></div>
            <button class="control-btn resetBtn tooltip" data-tip="Sƒ±fƒ±rla">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
            </button>
        </div>
    )}
  </div>
</div>

<style>
  :root {
    --status-text: #ffffff; 
    --status-shadow: 0 1px 3px rgba(0,0,0,0.8);
  }
  :global(body.light) .go-app {
    --status-text: #2c3e50;
    --status-shadow: none;
  }
  .go-app { 
    display: flex; flex-direction: column; align-items: center; justify-content: flex-start;
    width: 100%; max-width: 100%; margin: 0 auto; padding: 10px 0; box-sizing: border-box; overflow-x: hidden; 
  }
  .status { 
    font-size: 1rem; font-weight: bold; margin-bottom: 8px; min-height: 1.5em;
    color: var(--status-text); text-shadow: var(--status-shadow); transition: color 0.3s ease; 
  }
  .top-info-bar { margin-bottom: 5px; display: flex; justify-content: center; width: 100%; }
  .turn-badge { 
    display: flex; align-items: center; gap: 8px; background: #2c3e50; border: 1px solid #34495e; 
    padding: 4px 12px; border-radius: 15px; color: #fff; font-weight: 600; font-size: 0.85rem; 
    box-shadow: 0 2px 5px rgba(0,0,0,0.3); 
  }
  
  /* --- TAHTA STƒ∞Lƒ∞ (B√úY√úT√úLD√ú) --- */
  .go-container { 
    display: block; padding: 0; box-sizing: border-box;
    background-color: #d4a76a;
    background-image: 
        repeating-linear-gradient(45deg, rgba(0,0,0,0.03) 0px, rgba(0,0,0,0.03) 2px, transparent 2px, transparent 6px),
        repeating-linear-gradient(-45deg, rgba(0,0,0,0.02) 0px, rgba(0,0,0,0.02) 2px, transparent 2px, transparent 8px),
        linear-gradient(to bottom, rgba(0,0,0,0.05), transparent);
    background-size: 120px 120px, 120px 120px, auto;
    border-radius: 2px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); border: 3px solid #8c5e2a; 
    position: relative; z-index: 10; 
    
    /* G√úNCELLENEN BOYUTLAR */
    width: 98vw; /* Mobilde neredeyse tam geni≈ülik */
    max-width: 750px; /* 480px yerine 750px yapƒ±ldƒ± (Masa√ºst√º i√ßin b√ºy√ºd√º) */
    aspect-ratio: 1 / 1; 
    max-height: 80vh; /* 65vh yerine 80vh yapƒ±ldƒ± (Dikeyde daha √ßok yer) */
    
    height: auto; margin: 0 auto; 
  }
  
  @media (max-height: 600px) {
      .go-container { max-height: 90vh; width: auto; aspect-ratio: 1 / 1; }
  }

  canvas { display: block; width: 100% !important; height: 100% !important; touch-action: none; }
  .bottom-controls { margin-top: 15px; width: 100%; display: flex; justify-content: center; padding-bottom: 20px; }
  .teacher-group { 
      display: flex; gap: 10px; align-items: center; flex-wrap: wrap; justify-content: center; 
      background: rgba(44, 62, 80, 0.95); padding: 10px 15px; border-radius: 20px;
      border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 4px 15px rgba(0,0,0,0.3); max-width: 95%; 
  }
  .divider { width: 1px; height: 24px; background: rgba(255,255,255,0.2); margin: 0 4px; }
  .control-btn { 
    width: 42px; height: 42px; border-radius: 50%; background: transparent; border: 1px solid transparent; 
    color: #ecf0f1; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s ease; flex-shrink: 0; 
  }
  .control-btn:hover { background: rgba(255,255,255,0.15); transform: scale(1.05); color: #fff; }
  .control-btn.active { background: #3498db; border-color: #2980b9; box-shadow: 0 0 12px rgba(52, 152, 219, 0.6); }
  .size-selector { display: flex; gap: 4px; margin-right: 4px; }
  .size-btn {
      background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #bdc3c7;
      border-radius: 4px; padding: 6px 8px; font-size: 0.8rem; cursor: pointer; transition: all 0.2s;
  }
  .size-btn:hover { color: #fff; background: rgba(255,255,255,0.2); }
  .size-btn.active { background: #3498db; color: #fff; border-color: #3498db; font-weight: bold; }
  .turn-indicator { width: 18px; height: 18px; border-radius: 50%; box-shadow: 0 2px 4px rgba(0,0,0,0.4); }
  .turn-indicator.black { background: #000; border: 1px solid rgba(255,255,255,0.3); }
  .turn-indicator.white { background: #fff; border: 1px solid #999; }
  .tooltip { position: relative; }
  .tooltip:hover::after { 
    content: attr(data-tip); position: absolute; bottom: 135%; left: 50%; transform: translateX(-50%); 
    background: rgba(0,0,0,0.95); color: #fff; padding: 6px 12px; border-radius: 6px; font-size: 0.8rem; 
    white-space: nowrap; pointer-events: none; opacity: 0; animation: fadeIn 0.2s forwards; z-index: 20; 
  }
  @keyframes fadeIn { to { opacity: 1; } }
</style>

<script>
  const setupBoard = () => {
    document.querySelectorAll('.go-app').forEach(appElement => {
      const app = appElement as HTMLElement;

      if (app.getAttribute('data-initialized')) return;
      
      const canvas = app.querySelector('.goBoard') as HTMLCanvasElement;
      const statusDiv = app.querySelector('.status') as HTMLElement;
      
      const isTeacher = app.getAttribute('data-teacher') === 'true';
      const isJoseki = app.getAttribute('data-joseki') === 'true'; 
      
      if (!canvas) return; 

      const ctx = canvas.getContext('2d', { alpha: true });
      if (!ctx) return;
      
      let size = 19; 
      const resolution = 3; // 2'den 3'e √ßƒ±karƒ±ldƒ± (Daha keskin g√∂r√ºnt√º)
      const boardDisplaySize = 800; // 500'den 800'e √ßƒ±karƒ±ldƒ± (Canvas i√ß boyutu b√ºy√ºd√º)
      let padding = 35 * resolution; 
      let mode = isTeacher ? 'SETUP' : 'SOLVE';

      let boardHistory: any[] = [];
      let labels: any[][] = []; 
      let isLabelMode = false; 
      let labelCounter = 1;  

      let stones: any[][] = []; 
      let currentColor = 'black'; 
      let initialStonesState = ""; 
      let recordingStartColor = 'black'; 

      let moveTree: any = { children: [] }; 
      let currentNode: any = moveTree;      
      let currentPathStack: any[] = [];
      let lastMove: {x: number, y: number} | null = null; 
      
      let hasSolution = false;
      let hoverPos = { x: -1, y: -1 };
      let isLocked = false;

      const updateCanvasSize = () => {
          if (canvas) {
            canvas.width = boardDisplaySize * resolution; 
            canvas.height = boardDisplaySize * resolution;
          }
      };
      updateCanvasSize();

      const initStones = (newSize: number) => { 
          stones = Array(newSize).fill(0).map(() => Array(newSize).fill(null)); 
          labels = Array(newSize).fill(0).map(() => Array(newSize).fill(null));
      };
      
      const safeUnlock = () => {
        window.dispatchEvent(new CustomEvent('unlock-next-problem'));
        let attempts = 0;
        const interval = setInterval(() => {
            attempts++;
            const nextButtons = document.querySelectorAll('#nextBtn, .next-problem-btn, [data-action="next"]');
            let found = false;
            nextButtons.forEach(btn => {
                if (btn instanceof HTMLElement) {
                    btn.removeAttribute('disabled'); 
                    btn.style.opacity = "1"; 
                    btn.style.pointerEvents = "auto";
                    btn.style.cursor = "pointer"; 
                    btn.classList.remove('disabled', 'opacity-50', 'pointer-events-none', 'cursor-not-allowed');
                    btn.style.display = ''; 
                    found = true;
                }
            });
            if (found || attempts > 10) clearInterval(interval);
        }, 100);
        
        try { 
            if (typeof (window as any).handleMoveResult === 'function') (window as any).handleMoveResult(true); 
        } catch(e) {}
      };

      function updateStatusText(text: string, color: string) {
          if (statusDiv) { statusDiv.innerText = text; statusDiv.style.color = color; }
      }

      const savedData = app.getAttribute('data-problem');
      if (savedData) {
        try {
          const prob = JSON.parse(savedData);
          size = prob.size || 19;
          initStones(size);
          if (prob.labels) labels = typeof prob.labels === 'string' ? JSON.parse(prob.labels) : prob.labels;
          if (prob.turn) currentColor = prob.turn; else currentColor = 'black';

          if (prob.initialState) {
             initialStonesState = prob.initialState;
             const parsedState = JSON.parse(prob.initialState);
             if (Array.isArray(parsedState)) {
                if (Array.isArray(parsedState[0])) stones = parsedState;
                else (parsedState as any[]).forEach((s: any) => { if (s && s.x !== undefined) stones[s.x][s.y] = { color: s.color }; });
             }
          }
          if (prob.solution) {
              if (Array.isArray(prob.solution)) {
                  if (prob.solution.length > 0) {
                      let ptr = moveTree;
                      prob.solution.forEach((move: any) => {
                          const newNode = { ...move, children: [], status: null };
                          ptr.children.push(newNode); ptr = newNode;
                      });
                      ptr.status = 'correct'; hasSolution = true;
                  } else { hasSolution = false; }
              } else if (prob.solution.children && prob.solution.children.length > 0) {
                  moveTree = prob.solution; hasSolution = true;
              } else { hasSolution = false; }
          } else { hasSolution = false; }

          currentNode = moveTree; 
          if (!isTeacher) mode = 'SOLVE';
        } catch (e) { console.error(e); }
      } else {
          initStones(size); hasSolution = false;
      }

      if (!isTeacher && !hasSolution && !isJoseki) {
          setTimeout(() => { updateStatusText("Analiz Modu (Cevap gerekmez)", '#3498db'); safeUnlock(); }, 100);
      } else if (isJoseki) {
          setTimeout(() => { updateStatusText("Joseki Ke≈üif Modu", '#f1c40f'); }, 100);
      }

      const changeBoardSize = (newSize: number) => {
          size = newSize;
          initStones(size);
          moveTree = { children: [] }; currentNode = moveTree; currentPathStack = [];
          initialStonesState = ""; currentColor = 'black'; lastMove = null;
          document.querySelectorAll('.size-btn').forEach(btn => {
              if(btn.getAttribute('data-size') == newSize.toString()) btn.classList.add('active'); else btn.classList.remove('active');
          });
          drawBoard(); updateStatusText(`${size}x${size} Tahta Hazƒ±r`, '#fff');
      };

      if (isTeacher) {
          app.querySelectorAll('.size-btn').forEach(btn => {
              btn.addEventListener('click', (e) => {
                  const target = e.target as HTMLElement;
                  const s = parseInt(target.getAttribute('data-size') || "19");
                  changeBoardSize(s);
              });
          });
      }

      const isOnBoard = (x: number, y: number) => x >= 0 && x < size && y >= 0 && y < size;

      const getLiberties = (x: number, y: number, color: string, checked = new Set()) => {
          const key = `${x},${y}`; if (checked.has(key)) return 0; checked.add(key);
          let liberties = 0; const neighbors = [[x+1, y], [x-1, y], [x, y+1], [x, y-1]];
          neighbors.forEach(([nx, ny]) => {
              if (!isOnBoard(nx, ny)) return; const stone = stones[nx][ny];
              if (!stone) liberties++; else if (stone.color === color) liberties += getLiberties(nx, ny, color, checked);
          });
          return liberties;
      };

      const removeGroup = (x: number, y: number, color: string) => {
          const stone = stones[x][y]; if (!stone || stone.color !== color) return;
          stones[x][y] = null; const neighbors = [[x+1, y], [x-1, y], [x, y+1], [x, y-1]];
          neighbors.forEach(([nx, ny]) => { if (isOnBoard(nx, ny)) removeGroup(nx, ny, color); });
      };

      const playMove = (x: number, y: number, color: string) => {
        if (stones[x][y]) return false;
        const originalStones = JSON.stringify(stones);
        stones[x][y] = { color };
        let capturedAny = false; const opponent = color === 'black' ? 'white' : 'black';
        const neighbors = [[x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]];
        neighbors.forEach(([nx, ny]) => {
            if (isOnBoard(nx, ny) && stones[nx][ny] && stones[nx][ny].color === opponent) {
                if (getLiberties(nx, ny, opponent) === 0) { removeGroup(nx, ny, opponent); capturedAny = true; }
            }
        });
        if (!capturedAny && getLiberties(x, y, color) === 0) {
            stones = JSON.parse(originalStones); updateStatusText("ƒ∞ntihar hamlesi yasak!", "#e74c3c"); return false;
        }
        const newStateString = JSON.stringify(stones);
        if (boardHistory.length > 0 && boardHistory[boardHistory.length - 1] === newStateString) {
            stones = JSON.parse(originalStones); updateStatusText("Ko Kuralƒ±!", "#e74c3c"); return false;
        }
        boardHistory.push(originalStones); if (boardHistory.length > 2) boardHistory.shift();
        lastMove = { x, y }; 
        return true;
      };

      const drawBoard = () => {
        if (!canvas) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const cellSize = (canvas.width - padding * 2) / (size - 1);

        // √áizgiler
        ctx.lineWidth = 1 * resolution; ctx.strokeStyle = '#000'; ctx.beginPath();
        for (let i = 0; i < size; i++) {
          const pos = Math.round(padding + i * cellSize);
          ctx.moveTo(pos, padding); ctx.lineTo(pos, canvas.height - padding);
          ctx.moveTo(padding, pos); ctx.lineTo(canvas.width - padding, pos);
        }
        ctx.stroke();

        // Koordinatlar
        ctx.fillStyle = '#000'; ctx.font = `${10 * resolution}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        const labelOffset = padding / 1.5;
        for (let i = 0; i < size; i++) {
            const pos = Math.round(padding + i * cellSize);
            const labelChar = String.fromCharCode(65 + (i >= 8 ? i + 1 : i)); // 'I' atlamasƒ± eklenmeli gerekirse
            ctx.fillText(labelChar, pos, canvas.height - labelOffset);
            const labelNum = (size - i).toString();
            ctx.fillText(labelNum, canvas.width - labelOffset, pos);
        }

        // Hoshi Noktalarƒ±
        const hoshiCoords = size === 19 ? [3, 9, 15] : size === 13 ? [3, 6, 9] : [2, 4, 6];
        if (size >= 9) {
          ctx.fillStyle = '#000';
          hoshiCoords.forEach(hx => { hoshiCoords.forEach(hy => {
              ctx.beginPath(); ctx.arc(padding + hx * cellSize, padding + hy * cellSize, 2 * resolution, 0, Math.PI * 2); ctx.fill();
            }); });
        }
        
        // Etiketler
        ctx.fillStyle = "#000"; ctx.font = `bold ${cellSize * 0.5}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        for (let x = 0; x < size; x++) {
            for (let y = 0; y < size; y++) {
                if (labels[x][y]) {
                    const posX = padding + x * cellSize; const posY = padding + y * cellSize; ctx.fillText(labels[x][y], posX, posY);
                }
            }
        }

        // Mevcut Ta≈ülar
        stones.forEach((row, x) => row.forEach((stone, y) => { 
            if (stone) drawStone(x, y, stone.color, cellSize, 1, false); 
        }));

        // --- JOSEKI HAYALET HAMLELERƒ∞ (BRANCHES) ---
        if (isJoseki && currentNode.children && currentNode.children.length > 0) {
            currentNode.children.forEach((child: any) => {
                 if(!stones[child.x][child.y]) {
                     drawStone(child.x, child.y, child.color, cellSize, 0.4, true);
                 }
            });
        }
        
        // Hover Ta≈üƒ±
        if (!isLocked && hoverPos.x >= 0 && hoverPos.x < size && hoverPos.y >= 0 && hoverPos.y < size) {
          if (!stones[hoverPos.x][hoverPos.y]) {
            drawStone(hoverPos.x, hoverPos.y, currentColor, cellSize, 0.5, false);
          }
        }
      };

      const drawStone = (x: number, y: number, color: string, cellSize: number, opacity: number, isGhost: boolean) => {
        const posX = padding + x * cellSize; const posY = padding + y * cellSize; 
        const radius = cellSize * 0.48; 
        ctx.save(); ctx.globalAlpha = opacity;
        
        // --- PARLAMA EFEKTƒ∞ (GLOW) ---
        const isLastMove = lastMove && lastMove.x === x && lastMove.y === y && opacity === 1;
        
        if (isLastMove) {
            ctx.shadowColor = "#3498db"; 
            ctx.shadowBlur = 15 * resolution;
        } else if (isGhost) {
            ctx.shadowColor = color === 'black' ? "#000" : "#fff";
            ctx.shadowBlur = 10 * resolution; 
        }

        ctx.beginPath(); ctx.arc(posX, posY, radius, 0, Math.PI * 2);
        ctx.fillStyle = color === 'black' ? "#000" : "#fff";
        ctx.fill(); 

        if (color === 'white') { ctx.lineWidth = 0.8 * resolution; ctx.strokeStyle = "#000"; ctx.stroke(); }
        
        if (isGhost) {
            ctx.fillStyle = color === 'black' ? 'rgba(255,255,255,0.5)' : 'rgba(0,0,0,0.5)';
            ctx.beginPath(); ctx.arc(posX, posY, radius * 0.3, 0, Math.PI * 2); ctx.fill();
        }

        ctx.restore();
      };

      canvas.addEventListener('mousemove', (e: MouseEvent) => {
        if (mode === 'SOLVE' && isLocked) { canvas.style.cursor = 'default'; return; }
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height;
        const mouseX = (e.clientX - rect.left) * scaleX - padding;
        const mouseY = (e.clientY - rect.top) * scaleY - padding;
        const cellSize = (canvas.width - padding * 2) / (size - 1);
        const x = Math.round(mouseX / cellSize); const y = Math.round(mouseY / cellSize);
        if (x >= 0 && x < size && y >= 0 && y < size) { if (hoverPos.x !== x || hoverPos.y !== y) { hoverPos = { x, y }; canvas.style.cursor = 'pointer'; drawBoard(); } } 
        else { if (hoverPos.x !== -1) { hoverPos = { x: -1, y: -1 }; canvas.style.cursor = 'default'; drawBoard(); } }
      });
      canvas.addEventListener('mouseleave', () => { hoverPos = { x: -1, y: -1 }; drawBoard(); });

      canvas.addEventListener('click', (e) => {
        if (mode === 'SOLVE' && isLocked) { updateStatusText("Tekrar denemek i√ßin 'Yenile' butonuna basƒ±n.", '#e74c3c'); return; }
        if (hoverPos.x === -1) return;
        const x = hoverPos.x; const y = hoverPos.y;
        
        if (isLabelMode) {
            if (labels[x][y]) labels[x][y] = null; else labels[x][y] = labelCounter++;
            drawBoard(); return; 
        }

        if (mode === 'SETUP') { 
            stones[x][y] = stones[x][y] && stones[x][y].color === currentColor ? null : { color: currentColor }; drawBoard();
        } 
        else if (mode === 'RECORD') { 
            if (stones[x][y]) return; 
            const stateBeforeMove = JSON.stringify(stones); const colorBeforeMove = currentColor;
            if (!playMove(x, y, currentColor)) return;
            let existingChild = currentNode.children.find((child: any) => child.x === x && child.y === y);
            if (existingChild) {
                currentPathStack.push({ node: currentNode, stonesSnapshot: stateBeforeMove, turn: colorBeforeMove });
                currentNode = existingChild; updateStatusText(`Mevcut dalda ilerlendi.`, '#3498db');
            } else {
                const newNode = { x, y, color: currentColor, children: [], status: null };
                currentNode.children.push(newNode);
                currentPathStack.push({ node: currentNode, stonesSnapshot: stateBeforeMove, turn: colorBeforeMove });
                currentNode = newNode; updateStatusText("Yeni varyasyon kaydediliyor...", '#f1c40f');
            }
            currentColor = currentColor === 'black' ? 'white' : 'black'; drawBoard();
        } 
        else if (mode === 'SOLVE') {
            const nextNode = currentNode.children.find((child: any) => child.x === x && child.y === y);
            
            if (isJoseki) {
                if (nextNode) {
                    playMove(x, y, nextNode.color);
                    currentNode = nextNode;
                    currentColor = nextNode.color === 'black' ? 'white' : 'black';
                    updateStatusText("Varyasyon se√ßildi.", '#2ecc71');
                    drawBoard();
                } else if (!hasSolution) {
                     if (playMove(x, y, currentColor)) {
                        currentColor = currentColor === 'black' ? 'white' : 'black';
                        drawBoard();
                     }
                }
                return;
            }

            if (!hasSolution) {
                if (playMove(x, y, currentColor)) {
                    currentColor = currentColor === 'black' ? 'white' : 'black';
                    drawBoard(); updateStatusText("Analiz Modu", '#3498db');
                }
                return; 
            }
            if (nextNode) {
                playMove(x, y, nextNode.color);
                currentNode = nextNode; currentColor = currentColor === 'black' ? 'white' : 'black';
                drawBoard(); checkNodeStatus(currentNode); 
                if (currentNode.children && currentNode.children.length > 0 && !currentNode.status) {
                    setTimeout(() => {
                        const responseNode = currentNode.children[0];
                        playMove(responseNode.x, responseNode.y, responseNode.color);
                        currentNode = responseNode; currentColor = currentColor === 'black' ? 'white' : 'black';
                        drawBoard(); checkNodeStatus(currentNode);
                    }, 500); 
                }
            } else {
                updateStatusText("Tanƒ±msƒ±z hamle.", '#e74c3c'); isLocked = true;
                app.classList.add('locked'); 
                if (typeof (window as any).handleMoveResult === 'function') (window as any).handleMoveResult(false);
            }
        }
      });

      function checkNodeStatus(node: any) {
          if (node.status === 'correct') { finalizeSuccess(); return; } 
          if (node.status === 'wrong') { finalizeFail(); return; }
          if (!node.children || node.children.length === 0) { finalizeSuccess(); }
      }

      function finalizeSuccess() {
          updateStatusText("Tebrikler! Doƒüru √á√∂z√ºm.", '#2ecc71'); isLocked = true; app.classList.add('locked'); safeUnlock();
      }

      function finalizeFail() {
          updateStatusText("Yanlƒ±≈ü yol!", '#e74c3c'); isLocked = true; app.classList.add('locked');
          if (typeof (window as any).handleMoveResult === 'function') (window as any).handleMoveResult(false);
      }

      if (isTeacher) {
          app.querySelector('#undoBtn')?.addEventListener('click', () => {
              if (currentPathStack.length > 0) {
                  const lastStep = currentPathStack.pop();
                  if (lastStep) {
                      currentNode = lastStep.node; stones = JSON.parse(lastStep.stonesSnapshot); 
                      currentColor = lastStep.turn; lastMove = null;
                      updateStatusText("Geri alƒ±ndƒ±.", '#fff'); drawBoard();
                  }
              }
          });
          app.querySelector('#markCorrectBtn')?.addEventListener('click', () => {
              if (currentNode === moveTree) return; currentNode.status = 'correct'; updateStatusText("Bu dal 'DOƒûRU' i≈üaretlendi.", '#2ecc71');
          });
          app.querySelector('#markWrongBtn')?.addEventListener('click', () => {
              if (currentNode === moveTree) return; currentNode.status = 'wrong'; updateStatusText("Bu dal 'YANLI≈û' i≈üaretlendi.", '#e74c3c');
          });
          app.querySelector('.setupBtn')?.addEventListener('click', () => updateUI('SETUP'));
          app.querySelector('.recordBtn')?.addEventListener('click', () => updateUI('RECORD'));
          app.querySelector('.exportBtn')?.addEventListener('click', () => { 
            const title = prompt("Soru Ba≈ülƒ±ƒüƒ±:", "Yeni Soru") || "ƒ∞simsiz";
            const data = { 
                id: `prob-${Date.now()}`, size, labels: JSON.stringify(labels), turn: recordingStartColor,
                title, initialState: initialStonesState || JSON.stringify(stones), solution: moveTree 
            }; 
            console.log(JSON.stringify(data, null, 2)); alert("Veri console'a yazƒ±ldƒ±.");
          });
          const colorBtn = app.querySelector('.colorToggleBtn');
          if(colorBtn) colorBtn.addEventListener('click', () => {
            currentColor = currentColor === 'black' ? 'white' : 'black';
            const indicator = document.getElementById('teacherColorIndicator');
            if(indicator) { indicator.classList.toggle('black'); indicator.classList.toggle('white'); }
          });
      }

      const updateUI = (newMode: string) => {
        if (newMode === 'SETUP') {
            if (initialStonesState) {
                const parsed = JSON.parse(initialStonesState);
                if(Array.isArray(parsed) && Array.isArray(parsed[0])) stones = parsed;
                moveTree = { children: [] }; currentNode = moveTree; currentPathStack = [];
            }
            updateStatusText("Ta≈ülarƒ± dizin.", '#fff');
        }
        if (newMode === 'RECORD' && mode === 'SETUP') {
             initialStonesState = JSON.stringify(stones); recordingStartColor = currentColor; 
             moveTree = { children: [] }; currentNode = moveTree; currentPathStack = []; updateStatusText("Kayƒ±t Ba≈üladƒ±.", '#f1c40f');
        }
        mode = newMode;
        app.querySelectorAll('.control-btn').forEach(btn => btn.classList.remove('active'));
        if(newMode === 'SETUP') app.querySelector('.setupBtn')?.classList.add('active');
        if(newMode === 'RECORD') app.querySelector('.recordBtn')?.classList.add('active');
      };

      app.querySelector('.resetBtn')?.addEventListener('click', () => {
         updateStatusText("", "#fff"); isLocked= false; app.classList.remove('locked');
         labels = Array(size).fill(0).map(() => Array(size).fill(null)); labelCounter = 1; isLabelMode = false;
         app.querySelector('.labelBtn')?.classList.remove('active'); boardHistory = []; lastMove = null;
         
         if (isTeacher && mode === 'SETUP') { initStones(size); }
         else { 
             const probData = savedData ? JSON.parse(savedData) : {};
             if (probData.turn) currentColor = probData.turn; else currentColor = 'black';
             if(initialStonesState) {
                 const parsed = JSON.parse(initialStonesState);
                 if(Array.isArray(parsed) && Array.isArray(parsed[0])) stones = parsed; 
                 else { initStones(size); if(Array.isArray(parsed)) parsed.forEach((s: any) => {if(s) stones[s.x][s.y] = {color:s.color}}); }
             } else { initStones(size); }
             if (probData.labels) labels = typeof probData.labels === 'string' ? JSON.parse(probData.labels) : probData.labels;
             currentNode = moveTree; currentPathStack = [];
             if (!isTeacher && !hasSolution) { updateStatusText(isJoseki ? "Joseki Modu" : "Analiz Modu", '#3498db'); safeUnlock(); }
         }
         drawBoard();
      });

      const labelBtn = app.querySelector('.labelBtn');
      if (labelBtn) {
          labelBtn.addEventListener('click', () => {
              isLabelMode = !isLabelMode; 
              if (isLabelMode) { labelBtn.classList.add('active'); updateStatusText(`Etiket: ${labelCounter}`, '#000'); } 
              else { labelBtn.classList.remove('active'); updateStatusText("Mod kapatƒ±ldƒ±.", '#fff'); }
          });
      }

      if (!(window as any).resetAllBoards) {
          (window as any).resetAllBoards = () => { document.querySelectorAll('.resetBtn').forEach((btn: any) => btn.click()); };
      }

      app.setAttribute('data-initialized', 'true');
      drawBoard();
    }); 
  };
  document.addEventListener('astro:page-load', setupBoard);
  document.addEventListener('DOMContentLoaded', setupBoard);
</script>